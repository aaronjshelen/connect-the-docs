<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Document Knowledge Graph Analyzer</title>
    <script src="config.js"></script>
    <script src="theme-storage-system.js"></script>
    <script src="semantic-analyzer.js"></script>
    <script src="enhanced-prompts.js"></script>
    <script src="document-connection-analyzer.js"></script>

    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #111827;
        color: white;
        overflow: hidden;
      }

      .container {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        background: #1f2937;
        border-bottom: 1px solid #374151;
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .header-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .header-title h1 {
        font-size: 1.25rem;
        font-weight: 600;
      }

      .badge {
        background: #059669;
        color: white;
        padding: 0.125rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: 500;
      }

      .main-content {
        flex: 1;
        display: flex;
        overflow: hidden;
        position: relative;
      }

      .sidebar {
        width: 350px;
        min-width: 350px;
        background: #1f2937;
        border-right: 1px solid #374151;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        transition: transform 0.3s ease;
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 10;
      }

      .sidebar-hidden {
        transform: translateX(-100%);
      }

      .sidebar-toggle {
        position: fixed;
        top: 50%;
        left: 0;
        transform: translateY(-50%);
        background: rgba(31, 41, 55, 0.9);
        border: 1px solid #374151;
        border-left: none;
        border-radius: 0 0.5rem 0.5rem 0;
        padding: 1rem 0.5rem;
        cursor: pointer;
        z-index: 30;
        color: #f9fafb;
        font-size: 1.25rem;
        transition: all 0.3s ease;
      }

      .sidebar-toggle:hover {
        background: rgba(55, 65, 81, 0.9);
        padding-right: 0.75rem;
      }

      .sidebar-toggle-hidden {
        left: 350px;
      }

      .sidebar-section {
        padding: 1rem;
        border-bottom: 1px solid #374151;
      }

      .sidebar-section h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: #d1d5db;
      }

      .file-upload {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .upload-button {
        background: #374151;
        border: 2px dashed #6b7280;
        padding: 2rem;
        border-radius: 0.5rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        color: #9ca3af;
      }

      .upload-button:hover {
        background: #4b5563;
        border-color: #9ca3af;
      }

      .process-button {
        background: #059669;
        color: white;
        border: none;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        cursor: pointer;
        font-weight: 500;
        transition: background 0.2s;
      }

      .process-button:hover:not(:disabled) {
        background: #047857;
      }

      .process-button:disabled {
        background: #374151;
        cursor: not-allowed;
      }

      .analysis-panel {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        max-height: none;
      }

      .analysis-section {
        margin-bottom: 1.5rem;
        background: #374151;
        padding: 1rem;
        border-radius: 0.5rem;
      }

      .analysis-section h4 {
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #f3f4f6;
      }

      .stat-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .stat-item {
        background: #4b5563;
        padding: 0.5rem;
        border-radius: 0.25rem;
        text-align: center;
      }

      .stat-value {
        font-size: 1.25rem;
        font-weight: 600;
        color: #60a5fa;
      }

      .stat-label {
        font-size: 0.75rem;
        color: #9ca3af;
      }

      .theme-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #4b5563;
        border-radius: 0.25rem;
      }

      .theme-item {
        padding: 0.5rem;
        border-bottom: 1px solid #4b5563;
        display: flex;
        justify-content: between;
        align-items: center;
      }

      .theme-item:last-child {
        border-bottom: none;
      }

      .theme-label {
        flex: 1;
        font-size: 0.875rem;
      }

      .theme-badge {
        background: #1f2937;
        color: #9ca3af;
        padding: 0.125rem 0.375rem;
        border-radius: 0.125rem;
        font-size: 0.75rem;
      }

      .graph-container {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: #0a0a0a;
      }

      .graph-controls {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: rgba(31, 41, 55, 0.9);
        padding: 0.75rem;
        border-radius: 0.5rem;
        backdrop-filter: blur(8px);
        display: flex;
        gap: 0.5rem;
        z-index: 10;
      }

      .control-button {
        background: #374151;
        border: none;
        color: white;
        padding: 0.5rem;
        border-radius: 0.375rem;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.2s;
      }

      .control-button:hover {
        background: #4b5563;
      }

      .control-button:active {
        background: #1f2937;
      }

      .graph-overlay {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(31, 41, 55, 0.95);
        padding: 1.25rem;
        border-radius: 0.75rem;
        backdrop-filter: blur(12px);
        border: 1px solid #374151;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        z-index: 10;
        overflow: hidden;
      }

      .hover-overlay {
        max-width: 400px;
        max-height: 250px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .selected-overlay {
        max-height: 80vh;
        max-width: 400px;
        overflow-y: auto;
        animation: expandOverlay 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes expandOverlay {
        from {
          max-height: 250px;
          opacity: 0.8;
        }
        to {
          max-height: 80vh;
          opacity: 1;
        }
      }

      .node-details h4 {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: #f9fafb;
        line-height: 1.3;
      }

      .node-details p {
        font-size: 0.875rem;
        color: #d1d5db;
        margin-bottom: 0.75rem;
        line-height: 1.6;
      }

      .node-details .label {
        font-weight: 500;
        color: #9ca3af;
        display: inline-block;
        margin-right: 0.5rem;
      }

      .section-label {
        font-weight: 600;
        color: #60a5fa;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-top: 0.75rem;
        margin-bottom: 0.5rem;
        display: block;
      }

      .node-summary {
        color: #e5e7eb;
        font-size: 0.9rem;
        line-height: 1.6;
        margin-top: 0.5rem;
        white-space: pre-wrap;
      }

      .themes-list {
        margin-top: 1rem;
        padding-left: 0;
        list-style: none;
      }

      .themes-list li {
        color: #93c5fd;
        margin-bottom: 0.5rem;
        padding-left: 1.25rem;
        position: relative;
        line-height: 1.5;
      }

      .themes-list li::before {
        content: "•";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #60a5fa;
      }

      .connected-themes-list {
        margin-top: 0.5rem;
        padding-left: 0;
        list-style: none;
      }

      .connected-themes-list li {
        color: #a5b4fc;
        margin-bottom: 0.75rem;
        padding-left: 1.25rem;
        position: relative;
        line-height: 1.5;
      }

      .connected-themes-list li::before {
        content: "→";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #818cf8;
      }

      .connected-doc {
        color: #9ca3af;
        font-size: 0.85rem;
        font-style: italic;
        margin-left: 0.5rem;
      }

      .quotes-list {
        margin-top: 0.5rem;
        padding-left: 0;
        list-style: none;
      }

      .quotes-list li {
        color: #d1d5db;
        margin-bottom: 0.75rem;
        padding-left: 1rem;
        padding-right: 0.5rem;
        border-left: 3px solid #60a5fa;
        font-style: italic;
        line-height: 1.6;
        background: rgba(96, 165, 250, 0.05);
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
        border-radius: 0 0.25rem 0.25rem 0;
      }

      .expand-hint {
        color: #9ca3af;
        font-size: 0.8rem;
        font-style: italic;
        margin-top: 0.75rem;
        opacity: 0.8;
      }

      .chat-overlay {
        position: absolute;
        top: 1rem;
        left: 370px;
        width: 55%;
        max-width: 650px;
        z-index: 20;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .chat-overlay-centered {
        left: 50%;
        transform: translateX(-50%);
      }

      .chat-overlay-collapsed {
        max-height: 60px;
      }

      .chat-overlay-expanded {
        max-height: 500px;
      }

      .chat-header {
        padding: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .chat-input-overlay {
        width: 100%;
        background: rgba(31, 41, 55, 0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.3);
        padding: 0.75rem;
        border-radius: 0.5rem;
        color: #f9fafb;
        font-size: 0.875rem;
        outline: none;
        transition: all 0.2s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .chat-input-overlay:focus {
        background: rgba(31, 41, 55, 0.7);
        border-color: rgba(96, 165, 250, 0.4);
      }

      .typing-cursor {
        display: inline-block;
        margin-left: 2px;
        animation: blink 1s infinite;
        color: #60a5fa;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      .chat-messages {
        max-height: 400px;
        overflow-y: auto;
        padding: 0.75rem 0 0 0;
      }

      .chat-message {
        margin-bottom: 0.75rem;
        padding: 0.75rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        line-height: 1.6;
        background: rgba(31, 41, 55, 0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.3);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        white-space: pre-wrap;
      }

      .chat-message-user {
        background: rgba(31, 41, 55, 0.6);
        border-left: 3px solid rgba(156, 163, 175, 0.5);
      }

      .chat-message-assistant {
        background: rgba(31, 41, 55, 0.6);
        border-left: 3px solid rgba(156, 163, 175, 0.5);
      }

      .progress-bar {
        background: #374151;
        height: 4px;
        border-radius: 2px;
        overflow: hidden;
        margin-top: 0.5rem;
      }

      .progress-fill {
        background: #059669;
        height: 100%;
        transition: width 0.3s ease;
      }

      .loading-state {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: #9ca3af;
      }

      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #374151;
        border-top: 2px solid #059669;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .message {
        padding: 0.75rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
      }

      .message.success {
        background: rgba(5, 150, 105, 0.2);
        border: 1px solid #059669;
        color: #10b981;
      }

      .message.error {
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid #ef4444;
        color: #f87171;
      }

      .message.info {
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid #3b82f6;
        color: #60a5fa;
      }

      .chat-section {
        background: #374151;
        padding: 1rem;
        border-radius: 0.375rem;
        margin-bottom: 0.75rem;
      }

      .chat-input {
        width: 100%;
        background: #1f2937;
        border: 1px solid #4b5563;
        color: white;
        padding: 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        margin-top: 0.5rem;
      }

      .chat-input:focus {
        outline: none;
        border-color: #059669;
      }

      .search-results {
        max-height: 150px;
        overflow-y: auto;
        margin-top: 0.5rem;
        border: 1px solid #4b5563;
        border-radius: 0.25rem;
      }

      .search-result-item {
        padding: 0.5rem;
        border-bottom: 1px solid #4b5563;
        cursor: pointer;
        font-size: 0.875rem;
        transition: background 0.2s;
      }

      .search-result-item:hover {
        background: #4b5563;
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .config-section {
        background: #374151;
        padding: 0.75rem;
        border-radius: 0.375rem;
        margin-bottom: 0.75rem;
      }

      .config-section label {
        display: block;
        font-size: 0.75rem;
        color: #d1d5db;
        margin-bottom: 0.25rem;
      }

      .config-section input[type="range"] {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .config-section input[type="checkbox"] {
        margin-right: 0.5rem;
      }

      input[type="file"] {
        display: none;
      }

      /* Custom scrollbar styles */
      .sidebar::-webkit-scrollbar,
      .analysis-panel::-webkit-scrollbar,
      .theme-list::-webkit-scrollbar,
      .search-results::-webkit-scrollbar {
        width: 8px;
      }

      .sidebar::-webkit-scrollbar-track,
      .analysis-panel::-webkit-scrollbar-track,
      .theme-list::-webkit-scrollbar-track,
      .search-results::-webkit-scrollbar-track {
        background: #1f2937;
      }

      .sidebar::-webkit-scrollbar-thumb,
      .analysis-panel::-webkit-scrollbar-thumb,
      .theme-list::-webkit-scrollbar-thumb,
      .search-results::-webkit-scrollbar-thumb {
        background: #4b5563;
        border-radius: 4px;
      }

      .sidebar::-webkit-scrollbar-thumb:hover,
      .analysis-panel::-webkit-scrollbar-thumb:hover,
      .theme-list::-webkit-scrollbar-thumb:hover,
      .search-results::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useRef, useEffect } = React;

      const EnhancedDocumentAnalyzer = () => {
        // State management
        const [documents, setDocuments] = useState([]);
        const [graphData, setGraphData] = useState(null);
        const [selectedNode, setSelectedNode] = useState(null);
        const [hoveredNode, setHoveredNode] = useState(null);
        const [analysisReport, setAnalysisReport] = useState(null);
        const [loading, setLoading] = useState(false);
        const [processingProgress, setProcessingProgress] = useState(0);
        const [messages, setMessages] = useState([]);

        // Search and chat state
        const [searchQuery, setSearchQuery] = useState("");
        const [searchResults, setSearchResults] = useState([]);
        const [chatInput, setChatInput] = useState("");
        const [chatHistory, setChatHistory] = useState([]);
        const [chatExpanded, setChatExpanded] = useState(false);
        const [sidebarVisible, setSidebarVisible] = useState(true);
        const [typingMessageIndex, setTypingMessageIndex] = useState(null);
        const [displayedText, setDisplayedText] = useState({});
        const [selectedNodeDetails, setSelectedNodeDetails] = useState(null);
        const [typingNodeText, setTypingNodeText] = useState("");

        // Configuration state
        const [config, setConfig] = useState({
          minThemeConfidence: 0.7,
          maxThemesPerDocument: 8,
          semanticSimilarityThreshold: 0.7,
          connectionStrengthThreshold: 0.4,
          enableSemanticAnalysis: true,
          enableHierarchicalThemes: true,
        });

        // Refs
        const mountRef = useRef(null);
        const analyzerRef = useRef(null);
        const fileInputRef = useRef(null);
        const chatOverlayRef = useRef(null);
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const nodeObjectsRef = useRef({});
        const hoveredNodeRef = useRef(null);
        const selectedNodeRef = useRef(null);
        const focusPointRef = useRef(new THREE.Vector3(0, 0, 0)); // Track orbital center
        const controlsRef = useRef({
          rotation: { x: 0, y: 0 },
          autoRotate: true, // Start with auto-rotate enabled
        });

        // Initialize analyzer
        useEffect(() => {
          if (window.CONFIG && window.CONFIG.OPENAI_API_KEY) {
            analyzerRef.current = new DocumentConnectionAnalyzer(
              window.CONFIG.OPENAI_API_KEY
            );
            addMessage(
              "System initialized with enhanced analysis capabilities",
              "success"
            );
          } else {
            addMessage(
              "OpenAI API key not found. Please check your config.js file.",
              "error"
            );
          }
        }, []);

        // Sync hover and selection states with refs for animation loop
        useEffect(() => {
          hoveredNodeRef.current = hoveredNode;
        }, [hoveredNode]);

        useEffect(() => {
          selectedNodeRef.current = selectedNode;
        }, [selectedNode]);

        // Handle click outside chat to collapse it
        useEffect(() => {
          const handleClickOutside = (event) => {
            if (
              chatOverlayRef.current &&
              !chatOverlayRef.current.contains(event.target) &&
              chatExpanded
            ) {
              setChatExpanded(false);
            }
          };

          document.addEventListener("mousedown", handleClickOutside);
          return () => {
            document.removeEventListener("mousedown", handleClickOutside);
          };
        }, [chatExpanded]);

        // Resize renderer when sidebar is toggled
        useEffect(() => {
          if (rendererRef.current && cameraRef.current && mountRef.current) {
            // Wait for CSS transition to complete
            setTimeout(() => {
              const width = mountRef.current.clientWidth;
              const height = mountRef.current.clientHeight;

              cameraRef.current.aspect = width / height;
              cameraRef.current.updateProjectionMatrix();
              rendererRef.current.setSize(width, height);

              console.log("Renderer resized to:", width, "x", height);
            }, 300); // Match CSS transition duration
          }
        }, [sidebarVisible]);

        // Typewriter effect for chat messages
        useEffect(() => {
          if (typingMessageIndex !== null && chatHistory[typingMessageIndex]) {
            const message = chatHistory[typingMessageIndex];
            const fullText = message.content;
            let currentIndex = 0;

            const typingInterval = setInterval(() => {
              if (currentIndex <= fullText.length) {
                setDisplayedText((prev) => ({
                  ...prev,
                  [typingMessageIndex]: fullText.slice(0, currentIndex),
                }));
                currentIndex++;
              } else {
                clearInterval(typingInterval);
                setTypingMessageIndex(null);
              }
            }, 20); // 20ms per character

            return () => clearInterval(typingInterval);
          }
        }, [typingMessageIndex, chatHistory]);

        // Typewriter effect for selected node details
        useEffect(() => {
          if (selectedNodeDetails) {
            const fullText = selectedNodeDetails;
            let currentIndex = 0;

            const typingInterval = setInterval(() => {
              if (currentIndex <= fullText.length) {
                setTypingNodeText(fullText.slice(0, currentIndex));
                currentIndex++;
              } else {
                clearInterval(typingInterval);
              }
            }, 15); // 15ms per character for info box

            return () => clearInterval(typingInterval);
          } else {
            setTypingNodeText("");
          }
        }, [selectedNodeDetails]);

        // Initialize 3D graph when data is available
        useEffect(() => {
          if (graphData && mountRef.current) {
            console.log("useEffect triggered with graphData:", graphData);
            console.log("Nodes:", graphData.nodes?.length);
            console.log("Links:", graphData.links?.length);
            initializeThreeJSGraph();
          }
        }, [graphData]); // Added proper dependency

        const addMessage = (content, type = "info") => {
          setMessages((prev) => [
            ...prev.slice(-4),
            { content, type, timestamp: Date.now() },
          ]);
        };

        const handleFileUpload = (event) => {
          const files = Array.from(event.target.files);
          const filePromises = files.map((file) => {
            return new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                resolve({
                  filename: file.name,
                  title: file.name.replace(/\.[^/.]+$/, ""),
                  content: e.target.result,
                  size: file.size,
                });
              };
              reader.readAsText(file);
            });
          });

          Promise.all(filePromises)
            .then((loadedDocs) => {
              // Validate loaded documents
              const validDocs = loadedDocs.filter((doc) => {
                if (!doc || !doc.title || !doc.content) {
                  console.warn("Skipping invalid document:", doc);
                  return false;
                }
                return true;
              });

              if (validDocs.length !== loadedDocs.length) {
                addMessage(
                  `Loaded ${validDocs.length} valid documents (${
                    loadedDocs.length - validDocs.length
                  } skipped due to errors)`,
                  "info"
                );
              } else {
                addMessage(`Loaded ${validDocs.length} document(s)`, "success");
              }

              setDocuments((prev) => [...prev, ...validDocs]);
            })
            .catch((error) => {
              console.error("File loading error:", error);
              addMessage(`Error loading files: ${error.message}`, "error");
            });
        };

        const processDocuments = async () => {
          if (!analyzerRef.current || documents.length === 0) {
            addMessage(
              "No analyzer available or no documents to process",
              "error"
            );
            return;
          }

          setLoading(true);
          setProcessingProgress(0);
          addMessage("Starting enhanced document analysis...", "info");

          try {
            // Simulate progress updates
            const progressUpdates = [
              { progress: 20, message: "Extracting themes and definitions..." },
              {
                progress: 40,
                message: "Building optimized storage structure...",
              },
              { progress: 60, message: "Performing semantic analysis..." },
              { progress: 80, message: "Building relationship graph..." },
              { progress: 90, message: "Generating analysis report..." },
            ];

            let updateIndex = 0;
            const progressInterval = setInterval(() => {
              if (updateIndex < progressUpdates.length) {
                const update = progressUpdates[updateIndex];
                setProcessingProgress(update.progress);
                addMessage(update.message, "info");
                updateIndex++;
              }
            }, 2000);

            const result = await analyzerRef.current.processDocuments(
              documents,
              config
            );

            clearInterval(progressInterval);
            setProcessingProgress(100);

            if (result.success) {
              setGraphData(result.graphData);
              setAnalysisReport(result.analysisReport);
              addMessage(
                `Analysis completed successfully! Processed ${result.documentIds.length} documents in ${result.processingTime}ms`,
                "success"
              );

              // Log detailed results for debugging
              console.log("Analysis Results:", result);
              console.log("Graph Data:", result.graphData);
              console.log("Analysis Report:", result.analysisReport);
            } else {
              console.error("Analysis failed with details:", result);
              addMessage(`Analysis failed: ${result.error}`, "error");

              // Show additional debug info if available
              if (result.debugInfo) {
                console.log("Debug info:", result.debugInfo);
                if (
                  result.originalError &&
                  result.originalError !== result.error
                ) {
                  addMessage(
                    `Technical details: ${result.originalError}`,
                    "error"
                  );
                }
              }
            }
          } catch (error) {
            console.error("Processing error:", error);
            addMessage(`Processing error: ${error.message}`, "error");
          } finally {
            setLoading(false);
            setProcessingProgress(0);
          }
        };

        const initializeThreeJSGraph = () => {
          console.log("=== initializeThreeJSGraph called ===");
          console.log("mountRef.current:", mountRef.current);
          console.log("graphData:", graphData);

          if (!mountRef.current) {
            console.error("No mount ref!");
            return;
          }

          if (!graphData) {
            console.error("No graph data!");
            return;
          }

          if (!graphData.nodes || graphData.nodes.length === 0) {
            console.error("No nodes in graph data!");
            addMessage("No nodes to display in graph", "error");
            return;
          }

          console.log(
            `Found ${graphData.nodes.length} nodes and ${
              graphData.links?.length || 0
            } links`
          );

          // Clear any existing content
          while (mountRef.current.firstChild) {
            mountRef.current.removeChild(mountRef.current.firstChild);
          }

          // Initialize Three.js scene
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x0a0a0a);
          sceneRef.current = scene;

          const camera = new THREE.PerspectiveCamera(
            75,
            mountRef.current.clientWidth / mountRef.current.clientHeight,
            0.1,
            1000
          );
          camera.position.set(0, 0, 80); // Increased from 50 to zoom out
          cameraRef.current = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(
            mountRef.current.clientWidth,
            mountRef.current.clientHeight
          );
          mountRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          console.log("Scene, camera, and renderer initialized");

          // Add lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(20, 30, 50);
          scene.add(directionalLight);

          // Apply force-directed layout for better organization
          console.log("Applying force-directed layout...");
          applyForceDirectedLayout(graphData);

          graphData.nodes.forEach((node, i) => {
            console.log(
              `Node ${i} (${node.label}): x=${node.x.toFixed(
                2
              )}, y=${node.y.toFixed(2)}, z=${node.z.toFixed(2)}`
            );
          });

          // Create nodes
          const nodeObjects = {};

          console.log("Creating node meshes...");
          graphData.nodes.forEach((node, i) => {
            const size = ((node.size || 5) / 10) * 2; // Doubled node size
            const geometry = new THREE.SphereGeometry(size, 16, 16);

            let color;
            try {
              color = new THREE.Color(node.color || "#60a5fa");
            } catch (e) {
              console.warn(`Invalid color for node ${i}:`, node.color);
              color = new THREE.Color("#60a5fa");
            }

            const material = new THREE.MeshPhongMaterial({
              color: color,
              emissive: color,
              emissiveIntensity: 0.3,
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(node.x / 10, node.y / 10, node.z / 10);
            mesh.userData = { nodeId: node.id, nodeData: node };

            scene.add(mesh);
            nodeObjects[node.id] = mesh;

            console.log(`Added mesh for node ${i}: ${node.label}`);
          });

          // Store nodeObjects in ref for animation loop access
          nodeObjectsRef.current = nodeObjects;

          console.log(`Created ${Object.keys(nodeObjects).length} node meshes`);

          // Create links with visible tubes
          if (graphData.links && graphData.links.length > 0) {
            console.log("Creating links with tubes...");
            let successfulLinks = 0;

            graphData.links.forEach((link, i) => {
              const sourceNode = graphData.nodes.find(
                (n) => n.id === link.source
              );
              const targetNode = graphData.nodes.find(
                (n) => n.id === link.target
              );

              if (sourceNode && targetNode) {
                // Validate positions
                const sx = sourceNode.x / 10;
                const sy = sourceNode.y / 10;
                const sz = sourceNode.z / 10;
                const tx = targetNode.x / 10;
                const ty = targetNode.y / 10;
                const tz = targetNode.z / 10;

                // Check for valid numbers
                if (
                  isFinite(sx) &&
                  isFinite(sy) &&
                  isFinite(sz) &&
                  isFinite(tx) &&
                  isFinite(ty) &&
                  isFinite(tz)
                ) {
                  try {
                    // Create a tube between the two points
                    const start = new THREE.Vector3(sx, sy, sz);
                    const end = new THREE.Vector3(tx, ty, tz);

                    // Create a curve between start and end
                    const curve = new THREE.LineCurve3(start, end);

                    // Create tube geometry along the curve
                    const tubeGeometry = new THREE.TubeGeometry(
                      curve, // path
                      1, // tubular segments
                      0.08, // radius (thicker = more visible)
                      8, // radial segments
                      false // closed
                    );

                    // Create glowing material
                    const tubeMaterial = new THREE.MeshBasicMaterial({
                      color: 0x60a5fa, // Bright blue
                      transparent: true,
                      opacity: 0.8,
                    });

                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    scene.add(tube);
                    successfulLinks++;

                    if (i < 3) {
                      console.log(
                        `✓ Tube link ${i}: ${sourceNode.label} → ${targetNode.label}`
                      );
                    }
                  } catch (error) {
                    console.error(`Error creating tube for link ${i}:`, error);
                  }
                } else {
                  console.warn(
                    `Invalid positions for link ${i}: source(${sx},${sy},${sz}) target(${tx},${ty},${tz})`
                  );
                }
              } else {
                console.warn(
                  `Could not find nodes for link ${i}: source=${link.source}, target=${link.target}`
                );
              }
            });

            console.log(
              `✓ Created ${successfulLinks} tube links out of ${graphData.links.length} total`
            );
          } else {
            console.log("No links to create");
          }

          // Mouse interaction
          const raycaster = new THREE.Raycaster();
          const mouse = new THREE.Vector2();

          const onMouseClick = (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
              Object.values(nodeObjects)
            );

            if (intersects.length > 0) {
              const nodeData = intersects[0].object.userData.nodeData;
              console.log("Node clicked:", nodeData.label);

              // Stop auto-rotate when user clicks a node
              if (controlsRef.current.autoRotate) {
                controlsRef.current.autoRotate = false;
              }

              setSelectedNode(nodeData);

              // Prepare details text for typing effect
              const details = getNodeDetails(nodeData);
              if (details && details.summary) {
                setSelectedNodeDetails(details.summary);
              } else {
                setSelectedNodeDetails(null);
              }

              focusOnNode(nodeData); // Zoom in on clicked node
            } else {
              setSelectedNode(null);
              setSelectedNodeDetails(null);
            }
          };

          renderer.domElement.addEventListener("click", onMouseClick);

          // Camera controls
          let isDragging = false;
          let previousMousePosition = { x: 0, y: 0 };

          const onMouseDown = (event) => {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };

            // Stop auto-rotate when user starts interacting
            if (controlsRef.current.autoRotate) {
              controlsRef.current.autoRotate = false;
            }
          };

          const onMouseMove = (event) => {
            // Handle hover detection when not dragging
            if (!isDragging) {
              const rect = renderer.domElement.getBoundingClientRect();
              mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
              mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

              raycaster.setFromCamera(mouse, camera);
              const intersects = raycaster.intersectObjects(
                Object.values(nodeObjects)
              );

              if (intersects.length > 0) {
                const nodeData = intersects[0].object.userData.nodeData;
                setHoveredNode(nodeData);
                renderer.domElement.style.cursor = "pointer";
              } else {
                setHoveredNode(null);
                renderer.domElement.style.cursor = "default";
              }
              return;
            }

            // Handle dragging/rotation
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            controlsRef.current.rotation.y += deltaX * 0.01;
            controlsRef.current.rotation.x += deltaY * 0.01;

            controlsRef.current.rotation.x = Math.max(
              -Math.PI / 2,
              Math.min(Math.PI / 2, controlsRef.current.rotation.x)
            );

            // Get the focus point (selected node position or origin)
            const focusPoint = focusPointRef.current;

            // Calculate distance from camera to focus point
            const dx = camera.position.x - focusPoint.x;
            const dy = camera.position.y - focusPoint.y;
            const dz = camera.position.z - focusPoint.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate new camera position around the focus point
            camera.position.x =
              focusPoint.x +
              distance *
                Math.sin(controlsRef.current.rotation.y) *
                Math.cos(controlsRef.current.rotation.x);
            camera.position.y =
              focusPoint.y +
              distance * Math.sin(controlsRef.current.rotation.x);
            camera.position.z =
              focusPoint.z +
              distance *
                Math.cos(controlsRef.current.rotation.y) *
                Math.cos(controlsRef.current.rotation.x);

            camera.lookAt(focusPoint);

            previousMousePosition = { x: event.clientX, y: event.clientY };
          };

          const onMouseUp = () => {
            isDragging = false;
          };

          const onWheel = (event) => {
            event.preventDefault();

            // Stop auto-rotate when user scrolls
            if (controlsRef.current.autoRotate) {
              controlsRef.current.autoRotate = false;
            }

            const zoomSpeed = event.deltaY * 0.05;

            // Get the focus point (selected node position or origin)
            const focusPoint = focusPointRef.current;

            // Calculate current distance from camera to focus point
            const dx = camera.position.x - focusPoint.x;
            const dy = camera.position.y - focusPoint.y;
            const dz = camera.position.z - focusPoint.z;
            const currentDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate new distance with limits
            const newDistance = Math.max(
              15,
              Math.min(150, currentDistance + zoomSpeed)
            );
            const scale = newDistance / currentDistance;

            // Scale camera position relative to focus point
            camera.position.x = focusPoint.x + dx * scale;
            camera.position.y = focusPoint.y + dy * scale;
            camera.position.z = focusPoint.z + dz * scale;

            camera.lookAt(focusPoint);
          };

          renderer.domElement.addEventListener("mousedown", onMouseDown);
          renderer.domElement.addEventListener("mousemove", onMouseMove);
          renderer.domElement.addEventListener("mouseup", onMouseUp);
          renderer.domElement.addEventListener("wheel", onWheel);
          renderer.domElement.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );

          console.log("Starting render loop...");

          // Render loop
          const animate = () => {
            requestAnimationFrame(animate);

            if (controlsRef.current.autoRotate) {
              controlsRef.current.rotation.y += 0.005;

              // Get focus point and current distance
              const focusPoint = focusPointRef.current;
              const dx = camera.position.x - focusPoint.x;
              const dy = camera.position.y - focusPoint.y;
              const dz = camera.position.z - focusPoint.z;
              const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

              // Rotate around focus point
              camera.position.x =
                focusPoint.x +
                distance * Math.sin(controlsRef.current.rotation.y);
              camera.position.z =
                focusPoint.z +
                distance * Math.cos(controlsRef.current.rotation.y);
              camera.lookAt(focusPoint);
            }

            // Update node visual states for hover and selection
            Object.values(nodeObjectsRef.current).forEach((mesh) => {
              const nodeData = mesh.userData.nodeData;
              const isHovered =
                hoveredNodeRef.current &&
                hoveredNodeRef.current.id === nodeData.id;
              const isSelected =
                selectedNodeRef.current &&
                selectedNodeRef.current.id === nodeData.id;

              if (isSelected) {
                // Selected nodes: larger scale and brighter
                mesh.scale.set(1.5, 1.5, 1.5);
                mesh.material.emissiveIntensity = 0.8;
              } else if (isHovered) {
                // Hovered nodes: slightly larger and brighter
                mesh.scale.set(1.3, 1.3, 1.3);
                mesh.material.emissiveIntensity = 0.6;
              } else {
                // Normal nodes
                mesh.scale.set(1, 1, 1);
                mesh.material.emissiveIntensity = 0.3;
              }
            });

            renderer.render(scene, camera);
          };
          animate();

          console.log("Graph initialization complete!");
          addMessage(
            `Graph displayed with ${graphData.nodes.length} nodes`,
            "success"
          );
        };

        const applyForceDirectedLayout = (graphData) => {
          console.log(
            "=== Starting applyForceDirectedLayout (orbital layout) ==="
          );

          if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
            console.error("Invalid graphData");
            return;
          }

          const nodeCount = graphData.nodes.length;
          const isValid = (n) => n != null && isFinite(n) && !isNaN(n);

          // Helper to validate node positions
          const validateNode = (node, fallbackIndex) => {
            if (!isValid(node.x) || !isValid(node.y) || !isValid(node.z)) {
              const angle = (fallbackIndex / nodeCount) * Math.PI * 2;
              node.x = Math.cos(angle) * 150;
              node.y = 0;
              node.z = Math.sin(angle) * 150;
            }
          };

          // 🧩 Parent → children mapping
          const parentToChildren = {};
          if (graphData.links) {
            graphData.links.forEach((link) => {
              if (!parentToChildren[link.source])
                parentToChildren[link.source] = [];
              parentToChildren[link.source].push(link.target);
            });
          }

          // 🌐 INITIAL PARENT DISTRIBUTION (document nodes only)
          const parents = graphData.nodes.filter((n) => n.type === "DOCUMENT");
          const children = graphData.nodes.filter((n) => n.type !== "DOCUMENT");

          for (let i = 0; i < parents.length; i++) {
            const parent = parents[i];
            const angle = (i / parents.length) * Math.PI * 2;
            const radius = 60; // Reduced from 90 to bring nodes very close together
            parent.x = Math.cos(angle) * radius;
            parent.y = (Math.random() - 0.5) * 15; // Reduced vertical spread from 20
            parent.z = Math.sin(angle) * radius;
            validateNode(parent, i);
          }

          // 🪐 CHILDREN ORBITAL LAYOUT
          const orbitRadius = 22; // Reduced from 28 - children very close to parents
          for (const parentId in parentToChildren) {
            const parent = graphData.nodes.find((n) => n.id === parentId);
            if (!parent) continue;

            const childIds = parentToChildren[parentId];
            const childCount = childIds.length;

            for (let i = 0; i < childCount; i++) {
              const child = graphData.nodes.find((n) => n.id === childIds[i]);
              if (!child) continue;

              // Compute orbital position
              const angle = (i / childCount) * Math.PI * 2;
              const tilt = (Math.random() - 0.5) * 0.5; // some z-axis variance
              const radius = orbitRadius + Math.random() * 20;

              child.x = parent.x + Math.cos(angle) * radius;
              child.y = parent.y + Math.sin(angle) * radius * tilt;
              child.z = parent.z + Math.sin(angle) * radius;
            }
          }

          // 💥 Add global repulsion for better overall spacing
          const iterations = 150;
          const velocities = new Map();
          for (let i = 0; i < nodeCount; i++) {
            velocities.set(graphData.nodes[i].id, { x: 0, y: 0, z: 0 });
          }

          for (let iter = 0; iter < iterations; iter++) {
            const forces = new Map();
            for (let i = 0; i < nodeCount; i++) {
              forces.set(graphData.nodes[i].id, { x: 0, y: 0, z: 0 });
            }

            // Repulsion between all nodes
            for (let i = 0; i < nodeCount; i++) {
              for (let j = i + 1; j < nodeCount; j++) {
                const n1 = graphData.nodes[i];
                const n2 = graphData.nodes[j];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const dz = n2.z - n1.z;
                const distSq = Math.max(1, dx * dx + dy * dy + dz * dz);
                const dist = Math.sqrt(distSq);
                const repulsion = 5000 / distSq;

                const fx = (dx / dist) * repulsion;
                const fy = (dy / dist) * repulsion;
                const fz = (dz / dist) * repulsion;

                const f1 = forces.get(n1.id);
                const f2 = forces.get(n2.id);

                f1.x -= fx;
                f1.y -= fy;
                f1.z -= fz;
                f2.x += fx;
                f2.y += fy;
                f2.z += fz;
              }
            }

            // Apply velocity/damping
            const damping = 0.85;
            for (let i = 0; i < nodeCount; i++) {
              const node = graphData.nodes[i];
              const f = forces.get(node.id);
              const v = velocities.get(node.id);

              v.x = (v.x + f.x) * damping;
              v.y = (v.y + f.y) * damping;
              v.z = (v.z + f.z) * damping;

              node.x += v.x;
              node.y += v.y;
              node.z += v.z;
            }
          }

          // 🌎 Center and scale the graph
          let cx = 0,
            cy = 0,
            cz = 0;
          for (const node of graphData.nodes) {
            cx += node.x;
            cy += node.y;
            cz += node.z;
          }
          cx /= nodeCount;
          cy /= nodeCount;
          cz /= nodeCount;

          for (const node of graphData.nodes) {
            node.x -= cx;
            node.y -= cy;
            node.z -= cz;
          }

          console.log("✓ Orbital layout complete!");
        };

        const updateConfig = (key, value) => {
          setConfig((prev) => ({ ...prev, [key]: value }));
        };

        const handleSearch = (query) => {
          setSearchQuery(query);
          if (!query.trim() || !graphData) {
            setSearchResults([]);
            return;
          }

          const lowerQuery = query.toLowerCase();
          const results = [];

          // Search in document nodes
          graphData.nodes.forEach((node) => {
            if (node.label.toLowerCase().includes(lowerQuery)) {
              results.push({
                id: node.id,
                label: node.label,
                type: node.type,
                relevance: node.label.toLowerCase() === lowerQuery ? 1 : 0.5,
              });
            }
          });

          // Sort by relevance
          results.sort((a, b) => b.relevance - a.relevance);
          setSearchResults(results.slice(0, 10));
        };

        const handleSearchSelect = (nodeId) => {
          if (sceneRef.current && cameraRef.current) {
            const node = graphData.nodes.find((n) => n.id === nodeId);
            if (node) {
              focusOnNode(node);
              setSelectedNode(node);
            }
          }
          setSearchQuery("");
          setSearchResults([]);
        };

        // Helper function to get document summary and details
        const getNodeDetails = (node) => {
          if (!node) return null;

          // Find the original document
          const doc = documents.find(
            (d) =>
              d.title === node.label ||
              d.filename === node.label ||
              (node.type === "DOCUMENT" && d.title.includes(node.label))
          );

          let summary = "";
          let fullContent = "";
          let themes = [];
          let connectedThemes = [];
          let quotes = [];

          if (doc && doc.content) {
            fullContent = doc.content;

            // Create a meta-description summary that explains what the document is about
            // Rather than just extracting the first paragraphs
            const contentPreview = fullContent.slice(0, 2000); // Look at first 2000 chars for analysis

            // Determine document type/purpose based on content patterns
            let summaryIntro = "This document discusses ";

            if (
              contentPreview.match(
                /\b(research|study|findings|methodology|data|results|analysis)\b/i
              )
            ) {
              summaryIntro = "This research document explores ";
            } else if (
              contentPreview.match(/\b(story|narrative|character|plot|tale)\b/i)
            ) {
              summaryIntro = "This is a story about ";
            } else if (
              contentPreview.match(
                /\b(guide|tutorial|how to|instructions|steps)\b/i
              )
            ) {
              summaryIntro = "This guide explains ";
            } else if (
              contentPreview.match(/\b(report|overview|summary|analysis of)\b/i)
            ) {
              summaryIntro = "This report examines ";
            } else if (
              contentPreview.match(
                /\b(article|discusses|explores|investigates)\b/i
              )
            ) {
              summaryIntro = "This article discusses ";
            }

            // Extract key topics from the first few paragraphs
            const paragraphs = fullContent
              .split("\n\n")
              .filter((p) => p.trim().length > 50);

            // Build the summary with proper formatting
            let formattedSummary = summaryIntro;

            // Add the first paragraph as the main description
            if (paragraphs.length > 0) {
              formattedSummary += paragraphs[0].trim();
            }

            // Add analysis section if there are more paragraphs
            if (paragraphs.length > 1) {
              formattedSummary += "\n\nKey Points:\n";

              // Add up to 3 more paragraphs as bullet points or sections
              const analysisParagraphs = paragraphs.slice(1, 4);
              analysisParagraphs.forEach((para, idx) => {
                const trimmedPara = para.trim().slice(0, 300); // Limit each point
                formattedSummary += `\n• ${trimmedPara}`;
                if (para.length > 300) {
                  formattedSummary += "...";
                }
              });
            }

            summary = formattedSummary;

            if (summary.length > 1800) {
              summary = summary.slice(0, 1800).trim() + "...";
            }

            // Extract quotes (only actual quoted text from people)
            const quoteMatches = fullContent.match(
              /"([^"]+)"|"([^"]+)"|'([^']+)'/g
            );
            if (quoteMatches && quoteMatches.length > 0) {
              quotes = quoteMatches
                .slice(0, 3)
                .map((q) => q.replace(/["'"']/g, "").trim());
            }
            // No fallback - only show quotes if they actually exist in the document

            console.log("Extracted quotes:", quotes);
          }

          // Get themes from metadata
          if (node.metadata) {
            if (node.metadata.themes) {
              themes = node.metadata.themes;
            } else if (analysisReport && analysisReport.documentThemes) {
              const docThemes = analysisReport.documentThemes[node.id] || [];
              themes = docThemes.slice(0, 5);
            }
          }

          // Get connected themes with document references
          if (graphData && graphData.links) {
            console.log(
              "Checking connected themes for:",
              node.label,
              "type:",
              node.type
            );
            console.log("Total links in graph:", graphData.links.length);

            // Find all links connected to this node
            const nodeLinks = graphData.links.filter(
              (link) => link.source === node.id || link.target === node.id
            );

            console.log("Links connected to this node:", nodeLinks.length);

            nodeLinks.forEach((link) => {
              const connectedNodeId =
                link.source === node.id ? link.target : link.source;
              const connectedNode = graphData.nodes.find(
                (n) => n.id === connectedNodeId
              );

              console.log(
                "Examining connected node:",
                connectedNode?.label,
                "type:",
                connectedNode?.type
              );

              // Check if it's a theme or if this is a document and we found another document
              if (connectedNode) {
                // Case 1: Current node is a DOCUMENT, connected to a THEME
                if (
                  node.type === "DOCUMENT" &&
                  (connectedNode.type === "THEME" ||
                    connectedNode.type === "DEFINITION")
                ) {
                  // Find other documents connected to this theme
                  const otherDocs = graphData.links
                    .filter(
                      (l) =>
                        (l.source === connectedNodeId ||
                          l.target === connectedNodeId) &&
                        l.source !== node.id &&
                        l.target !== node.id
                    )
                    .map((l) => {
                      const docId =
                        l.source === connectedNodeId ? l.target : l.source;
                      const docNode = graphData.nodes.find(
                        (n) => n.id === docId && n.type === "DOCUMENT"
                      );
                      return docNode ? docNode.label : null;
                    })
                    .filter(Boolean);

                  console.log(
                    "Theme:",
                    connectedNode.label,
                    "shared with:",
                    otherDocs
                  );

                  connectedThemes.push({
                    theme: connectedNode.label,
                    connectedDocs: otherDocs,
                  });
                }
                // Case 2: Current node is a THEME, show which documents it connects
                else if (
                  (node.type === "THEME" || node.type === "DEFINITION") &&
                  connectedNode.type === "DOCUMENT"
                ) {
                  // For themes, show all connected documents
                  if (
                    !connectedThemes.find(
                      (ct) => ct.theme === "Connected Documents"
                    )
                  ) {
                    connectedThemes.push({
                      theme: "Connected Documents",
                      connectedDocs: [connectedNode.label],
                    });
                  } else {
                    const existingEntry = connectedThemes.find(
                      (ct) => ct.theme === "Connected Documents"
                    );
                    if (
                      existingEntry &&
                      !existingEntry.connectedDocs.includes(connectedNode.label)
                    ) {
                      existingEntry.connectedDocs.push(connectedNode.label);
                    }
                  }
                }
              }
            });

            console.log(
              "Final connected themes for",
              node.label,
              ":",
              connectedThemes
            );
          }

          const result = {
            summary,
            fullContent,
            themes,
            connectedThemes: connectedThemes.slice(0, 5), // Limit to 5 connections
            quotes: quotes.slice(0, 3), // Limit to 3 quotes
            doc,
          };

          console.log("getNodeDetails result:", result);
          return result;
        };

        // Parse markdown bold syntax (**text** or __text__) to HTML
        const parseMarkdownBold = (text) => {
          if (!text) return text;
          // Replace **text** with <strong>text</strong>
          return text
            .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>")
            .replace(/__([^_]+)__/g, "<strong>$1</strong>");
        };

        const handleChatSubmit = async () => {
          if (!chatInput.trim() || !analyzerRef.current) return;

          const userMessage = chatInput.trim();
          setChatInput("");

          setChatHistory((prev) => [
            ...prev,
            { role: "user", content: userMessage },
          ]);
          setLoading(true);

          try {
            // Build context for the LLM with FULL document content
            const context = {
              documents: documents.map((doc) => ({
                title: doc.title,
                content: doc.content, // Include full content
                filename: doc.filename,
              })),
              analysisReport: analysisReport,
              graphStats: graphData?.metadata,
              totalDocuments: documents.length,
              totalThemes: analysisReport?.overview?.totalThemes || 0,
              sharedThemes: analysisReport?.overview?.sharedThemes || 0,
              topSharedThemes:
                analysisReport?.themeAnalysis?.topSharedThemes
                  ?.slice(0, 5)
                  .map((t) => ({
                    label: t.label,
                    sharedBy: t.sharedBy.length,
                  })) || [],
              connectivity: analysisReport?.connectivity || {},
              themeCategories:
                analysisReport?.themeAnalysis?.themeCategories || {},
            };

            // Create a comprehensive document summary for the prompt
            const documentSummaries = context.documents
              .map((doc, idx) => {
                const preview = doc.content.slice(0, 500); // First 500 chars as preview
                return `Document ${idx + 1}: "${doc.title}"
Filename: ${doc.filename}
Content Preview: ${preview}${doc.content.length > 500 ? "..." : ""}
Full Content Length: ${doc.content.length} characters`;
              })
              .join("\n\n");

            const prompt = `You are an AI assistant with COMPLETE access to the document contents and their relationships. 

DOCUMENT LIBRARY:
${documentSummaries}

ANALYSIS INSIGHTS:
- Total documents: ${context.totalDocuments}
- Total themes identified: ${context.totalThemes}
- Shared themes across documents: ${context.sharedThemes}
- Top shared themes: ${context.topSharedThemes
              .map((t) => `"${t.label}" (${t.sharedBy} docs)`)
              .join(", ")}
- Most connected document: ${
              context.connectivity.mostConnectedDocument?.document?.title ||
              "N/A"
            }
- Isolated documents: ${context.connectivity.isolatedDocuments?.length || 0}

USER QUESTION: ${userMessage}

INSTRUCTIONS:
- Be clear and direct - length should match what's needed to answer properly
- Can be short (1 sentence) or longer (multiple paragraphs) depending on the question
- Use bullet points or numbered lists when listing multiple items
- Add line breaks between sections for readability
- Be specific and cite document titles when relevant
- Format with proper spacing:
  • Use blank lines between paragraphs
  • Use • or numbered lists for multiple items
  • Use **bold** for emphasis on key terms

Answer the question thoroughly but efficiently.`;

            // For document-specific queries, include the full content of relevant documents
            const relevantDocs = documents.filter(
              (doc) =>
                userMessage.toLowerCase().includes(doc.title.toLowerCase()) ||
                userMessage.toLowerCase().includes(doc.filename.toLowerCase())
            );

            let fullContextPrompt = prompt;

            if (relevantDocs.length > 0 && relevantDocs.length <= 3) {
              // If user is asking about specific documents, include their full content
              const fullContents = relevantDocs
                .map(
                  (doc) =>
                    `\n\n=== FULL CONTENT OF "${doc.title}" ===\n${doc.content}\n=== END OF "${doc.title}" ===`
                )
                .join("\n");

              fullContextPrompt = prompt + fullContents;
            } else if (
              userMessage.toLowerCase().includes("summarize") ||
              userMessage.toLowerCase().includes("summary") ||
              userMessage.toLowerCase().includes("about") ||
              userMessage.toLowerCase().includes("content")
            ) {
              // If asking for summaries, include all full contents
              const allContents = documents
                .map(
                  (doc) =>
                    `\n\n=== FULL CONTENT OF "${doc.title}" ===\n${doc.content}\n=== END OF "${doc.title}" ===`
                )
                .join("\n");

              fullContextPrompt = prompt + allContents;
            }

            const response = await fetch(
              "https://api.openai.com/v1/chat/completions",
              {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${window.CONFIG.OPENAI_API_KEY}`,
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  model: "gpt-4o-mini",
                  messages: [
                    {
                      role: "system",
                      content:
                        "You are a helpful assistant analyzing documents. Provide clear, well-formatted responses. Length should match the question - can be brief or detailed as needed. Use bullet points and line breaks for clarity. Use **bold** for emphasis.",
                    },
                    { role: "user", content: fullContextPrompt },
                  ],
                  temperature: 0.7,
                  max_tokens: 600, // Flexible for appropriate response length
                }),
              }
            );

            const data = await response.json();

            if (!response.ok) {
              throw new Error(data.error?.message || "API request failed");
            }

            const assistantMessage =
              data.choices?.[0]?.message?.content ||
              "I apologize, but I could not generate a response.";

            setChatHistory((prev) => {
              const newHistory = [
                ...prev,
                { role: "assistant", content: assistantMessage },
              ];
              // Trigger typing animation for the new message
              setTypingMessageIndex(newHistory.length - 1);
              return newHistory;
            });
          } catch (error) {
            console.error("Chat error:", error);
            setChatHistory((prev) => [
              ...prev,
              {
                role: "assistant",
                content: `Error: ${error.message}. Please check your API key and try again.`,
              },
            ]);
          } finally {
            setLoading(false);
          }
        };

        const focusOnNode = (node) => {
          if (!cameraRef.current) return;

          const targetPos = new THREE.Vector3(
            node.x / 10,
            node.y / 10,
            node.z / 10
          );

          // Update the focus point to the selected node
          focusPointRef.current.copy(targetPos);

          const distance = 20;
          const direction = new THREE.Vector3(0, 0, 1);

          const startPos = cameraRef.current.position.clone();
          const endPos = targetPos
            .clone()
            .add(direction.multiplyScalar(distance));

          const duration = 1000;
          const startTime = Date.now();

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            cameraRef.current.position.lerpVectors(startPos, endPos, eased);
            cameraRef.current.lookAt(targetPos);

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // After animation completes, update rotation angles to match final camera position
              const dx = cameraRef.current.position.x - targetPos.x;
              const dy = cameraRef.current.position.y - targetPos.y;
              const dz = cameraRef.current.position.z - targetPos.z;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

              controlsRef.current.rotation.x = Math.asin(dy / dist);
              controlsRef.current.rotation.y = Math.atan2(dx, dz);
            }
          };
          animate();
        };

        const toggleAutoRotate = () => {
          const newState = !controlsRef.current.autoRotate;

          // When enabling auto-rotate, sync rotation angles to current camera position
          if (newState && cameraRef.current) {
            const focusPoint = focusPointRef.current;
            const dx = cameraRef.current.position.x - focusPoint.x;
            const dy = cameraRef.current.position.y - focusPoint.y;
            const dz = cameraRef.current.position.z - focusPoint.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate current rotation angles from camera position
            if (distance > 0) {
              controlsRef.current.rotation.x = Math.asin(dy / distance);
              controlsRef.current.rotation.y = Math.atan2(dx, dz);
            }
          }

          controlsRef.current.autoRotate = newState;
        };

        const resetCamera = () => {
          if (!cameraRef.current) return;

          // Reset focus point to origin
          focusPointRef.current.set(0, 0, 0);

          // Clear selected node
          setSelectedNode(null);

          const startPos = cameraRef.current.position.clone();
          const endPos = new THREE.Vector3(0, 0, 80); // Match initial camera position
          const duration = 1000;
          const startTime = Date.now();

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            cameraRef.current.position.lerpVectors(startPos, endPos, eased);
            cameraRef.current.lookAt(0, 0, 0);

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Reset rotation angles
              controlsRef.current.rotation.x = 0;
              controlsRef.current.rotation.y = 0;
            }
          };
          animate();
        };

        return (
          <div className="container">
            <div className="header">
              <div className="header-title">
                <h1>Enhanced Document Knowledge Graph Analyzer</h1>
                <span className="badge">Enhanced</span>
              </div>
              <div style={{ fontSize: "0.875rem", color: "#9ca3af" }}>
                {documents.length} documents loaded
              </div>
            </div>

            <div className="main-content">
              {/* Sidebar Toggle Button */}
              <button
                className={`sidebar-toggle ${
                  !sidebarVisible ? "" : "sidebar-toggle-hidden"
                }`}
                onClick={() => setSidebarVisible(!sidebarVisible)}
                title={sidebarVisible ? "Hide Sidebar" : "Show Sidebar"}
              >
                {sidebarVisible ? "◀" : "▶"}
              </button>

              <div
                className={`sidebar ${!sidebarVisible ? "sidebar-hidden" : ""}`}
              >
                <div className="sidebar-section">
                  <h3>Document Upload</h3>
                  <div className="file-upload">
                    <div
                      className="upload-button"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <div>📄</div>
                      <div>Drop files here or click to browse</div>
                      <div style={{ fontSize: "0.75rem", marginTop: "0.5rem" }}>
                        Supports .txt files
                      </div>
                    </div>
                    <input
                      ref={fileInputRef}
                      type="file"
                      multiple
                      accept=".txt"
                      onChange={handleFileUpload}
                    />
                    <button
                      className="process-button"
                      onClick={processDocuments}
                      disabled={loading || documents.length === 0}
                    >
                      {loading ? (
                        <div className="loading-state">
                          <div className="spinner"></div>
                          Processing...
                        </div>
                      ) : (
                        "Analyze Documents"
                      )}
                    </button>
                    {loading && (
                      <div className="progress-bar">
                        <div
                          className="progress-fill"
                          style={{ width: `${processingProgress}%` }}
                        ></div>
                      </div>
                    )}
                  </div>
                </div>

                <div className="sidebar-section">
                  <h3>Graph Controls</h3>
                  <div
                    style={{
                      display: "flex",
                      flexDirection: "column",
                      gap: "0.5rem",
                    }}
                  >
                    <button
                      className="control-button"
                      onClick={resetCamera}
                      title="Reset View"
                      style={{
                        width: "100%",
                        padding: "0.75rem",
                        fontSize: "1rem",
                      }}
                    >
                      🏠 Reset View
                    </button>
                    <button
                      className="control-button"
                      onClick={toggleAutoRotate}
                      title="Toggle Auto-Rotate"
                      style={{
                        width: "100%",
                        padding: "0.75rem",
                        fontSize: "1rem",
                      }}
                    >
                      🔄 Toggle Rotation
                    </button>
                  </div>
                </div>

                <div className="sidebar-section">
                  <h3>Search Graph</h3>
                  <div className="chat-section">
                    <input
                      type="text"
                      className="chat-input"
                      placeholder="Search for documents or themes..."
                      value={searchQuery}
                      onChange={(e) => handleSearch(e.target.value)}
                    />
                    {searchResults.length > 0 && (
                      <div className="search-results">
                        {searchResults.map((result, idx) => (
                          <div
                            key={idx}
                            className="search-result-item"
                            onClick={() => handleSearchSelect(result.id)}
                          >
                            <strong>{result.label}</strong>
                            <div
                              style={{ fontSize: "0.75rem", color: "#9ca3af" }}
                            >
                              {result.type}
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              </div>

              <div className="graph-container">
                <div
                  ref={mountRef}
                  style={{ width: "100%", height: "100%" }}
                ></div>

                {/* Chat Overlay at Top */}
                <div
                  ref={chatOverlayRef}
                  className={`chat-overlay ${
                    chatExpanded
                      ? "chat-overlay-expanded"
                      : "chat-overlay-collapsed"
                  } ${!sidebarVisible ? "chat-overlay-centered" : ""}`}
                >
                  <div className="chat-header">
                    <input
                      type="text"
                      className="chat-input-overlay"
                      placeholder="Ask questions about your documents..."
                      value={chatInput}
                      onChange={(e) => setChatInput(e.target.value)}
                      onFocus={() => setChatExpanded(true)}
                      onKeyPress={(e) => {
                        if (e.key === "Enter") {
                          handleChatSubmit();
                        }
                      }}
                    />
                  </div>

                  {chatExpanded && chatHistory.length > 0 && (
                    <div className="chat-messages">
                      {chatHistory.map((msg, idx) => {
                        const isTyping = typingMessageIndex === idx;
                        const textToShow = isTyping
                          ? displayedText[idx] || ""
                          : msg.content;

                        return (
                          <div
                            key={idx}
                            className={`chat-message chat-message-${msg.role}`}
                          >
                            <strong>
                              {msg.role === "user" ? "You" : "Assistant"}:
                            </strong>{" "}
                            <span
                              dangerouslySetInnerHTML={{
                                __html: parseMarkdownBold(textToShow),
                              }}
                            />
                            {isTyping && (
                              <span className="typing-cursor">▋</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>

                {selectedNode && (
                  <div className="graph-overlay selected-overlay">
                    <div className="node-details">
                      <h4>{selectedNode.label}</h4>
                      <p>
                        <span className="label">Type:</span> {selectedNode.type}
                      </p>
                      {(() => {
                        const details = getNodeDetails(selectedNode);
                        return details ? (
                          <>
                            {details.summary && (
                              <>
                                <span className="section-label">Summary</span>
                                <div className="node-summary">
                                  {typingNodeText || details.summary}
                                  {typingNodeText &&
                                    typingNodeText.length <
                                      details.summary.length && (
                                      <span className="typing-cursor">▋</span>
                                    )}
                                </div>
                              </>
                            )}
                            {details.connectedThemes &&
                              details.connectedThemes.length > 0 && (
                                <>
                                  <span className="section-label">
                                    Connected Themes
                                  </span>
                                  <ul className="connected-themes-list">
                                    {details.connectedThemes.map(
                                      (item, idx) => (
                                        <li key={idx}>
                                          <strong>{item.theme}</strong>
                                          <span className="connected-doc">
                                            {item.connectedDocs.length > 0 &&
                                              ` (shared with ${item.connectedDocs.join(
                                                ", "
                                              )})`}
                                          </span>
                                        </li>
                                      )
                                    )}
                                  </ul>
                                </>
                              )}
                            {details.quotes && details.quotes.length > 0 && (
                              <>
                                <span className="section-label">
                                  Key Quotes
                                </span>
                                <ul className="quotes-list">
                                  {details.quotes.map((quote, idx) => (
                                    <li key={idx}>{quote}</li>
                                  ))}
                                </ul>
                              </>
                            )}
                            {details.themes && details.themes.length > 0 && (
                              <>
                                <span className="section-label">
                                  Additional Themes
                                </span>
                                <ul className="themes-list">
                                  {details.themes.map((theme, idx) => (
                                    <li key={idx}>{theme}</li>
                                  ))}
                                </ul>
                              </>
                            )}
                          </>
                        ) : (
                          <>
                            {selectedNode.metadata && (
                              <>
                                {selectedNode.metadata.themeCount && (
                                  <p>
                                    <span className="label">Themes:</span>{" "}
                                    {selectedNode.metadata.themeCount}
                                  </p>
                                )}
                                {selectedNode.metadata.sharedBy && (
                                  <p>
                                    <span className="label">Shared by:</span>{" "}
                                    {selectedNode.metadata.sharedBy.length}{" "}
                                    documents
                                  </p>
                                )}
                                {selectedNode.metadata.category && (
                                  <p>
                                    <span className="label">Category:</span>{" "}
                                    {selectedNode.metadata.category}
                                  </p>
                                )}
                              </>
                            )}
                          </>
                        );
                      })()}
                    </div>
                  </div>
                )}

                {hoveredNode && !selectedNode && (
                  <div className="graph-overlay hover-overlay">
                    <div className="node-details">
                      <h4>{hoveredNode.label}</h4>
                      <p style={{ marginBottom: "0.5rem" }}>
                        <span className="label">Type:</span> {hoveredNode.type}
                      </p>
                      {(() => {
                        const details = getNodeDetails(hoveredNode);
                        return details && details.summary ? (
                          <>
                            <span className="section-label">Summary</span>
                            <div className="node-summary">
                              {details.summary.length > 200
                                ? details.summary.substring(0, 200).trim() +
                                  "..."
                                : details.summary}
                            </div>
                          </>
                        ) : hoveredNode.metadata ? (
                          <>
                            <span className="section-label">Metadata</span>
                            <p
                              style={{
                                fontSize: "0.8rem",
                                lineHeight: "1.4",
                                color: "#9ca3af",
                              }}
                            >
                              {hoveredNode.metadata.themeCount &&
                                `${hoveredNode.metadata.themeCount} themes • `}
                              {hoveredNode.metadata.sharedBy &&
                                `Shared by ${hoveredNode.metadata.sharedBy.length} docs`}
                              {hoveredNode.metadata.category &&
                                hoveredNode.metadata.category}
                            </p>
                          </>
                        ) : null;
                      })()}
                      <p className="expand-hint">(Click node for more)</p>
                    </div>
                  </div>
                )}

                {!graphData && (
                  <div
                    style={{
                      position: "absolute",
                      top: "50%",
                      left: "50%",
                      transform: "translate(-50%, -50%)",
                      textAlign: "center",
                      color: "#9ca3af",
                    }}
                  >
                    <div style={{ fontSize: "3rem", marginBottom: "1rem" }}>
                      📊
                    </div>
                    <div>
                      Upload documents and click "Analyze Documents" to see the
                      graph
                    </div>
                    <div style={{ fontSize: "0.875rem", marginTop: "0.5rem" }}>
                      Controls: Drag to rotate, Scroll to zoom, Click nodes to
                      select
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      ReactDOM.render(
        <EnhancedDocumentAnalyzer />,
        document.getElementById("root")
      );
    </script>
  </body>
</html>
