<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>c•nnect the d•cs</title>
    <script src="config.js"></script>
    <script src="theme-storage-system.js"></script>
    <script src="semantic-analyzer.js"></script>
    <script src="enhanced-prompts.js"></script>
    <script src="document-connection-analyzer.js"></script>

    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Fira Code", "Monaco", "Cascadia Code", "Roboto Mono",
          "Consolas", "Menlo", "Liberation Mono", "Courier New", monospace;
        background: #111827;
        color: white;
        overflow: hidden;
      }

      .container {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        background: #1f2937;
        border-bottom: 1px solid #374151;
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .header-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .header-title h1 {
        font-size: 1.25rem;
        font-weight: 600;
      }

      .badge {
        background: #059669;
        color: white;
        padding: 0.125rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: 500;
      }

      .main-content {
        flex: 1;
        display: flex;
        overflow: hidden;
        position: relative;
      }

      .sidebar {
        width: 350px;
        min-width: 350px;
        background: rgba(31, 41, 55, 0.7);
        backdrop-filter: blur(10px);
        border-right: 1px solid rgba(55, 65, 81, 0.5);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        transition: transform 0.3s ease;
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 10;
      }

      .sidebar-hidden {
        transform: translateX(-100%);
      }

      .sidebar-toggle {
        position: fixed;
        top: 50%;
        left: 0;
        transform: translateY(-50%);
        background: rgba(31, 41, 55, 0.9);
        border: 1px solid #374151;
        border-left: none;
        border-radius: 0 0.5rem 0.5rem 0;
        padding: 1rem 0.5rem;
        cursor: pointer;
        z-index: 30;
        color: #f9fafb;
        font-size: 1.25rem;
        transition: all 0.3s ease;
      }

      .sidebar-toggle:hover {
        background: rgba(55, 65, 81, 0.9);
        padding-right: 0.75rem;
      }

      .sidebar-toggle-hidden {
        left: 350px;
      }

      .sidebar-section {
        padding: 1rem;
        border-bottom: 1px solid #374151;
      }

      .sidebar-section h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: #d1d5db;
      }

      .file-upload {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .upload-button {
        background: #374151;
        border: 2px dashed #6b7280;
        padding: 2rem;
        border-radius: 0.5rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        color: #9ca3af;
        font-family: "Fira Code", "Monaco", "Consolas", monospace;
      }

      .upload-button:hover {
        background: #4b5563;
        border-color: #9ca3af;
      }

      .process-button {
        background: #059669;
        color: white;
        border: none;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        cursor: pointer;
        font-weight: 500;
        transition: background 0.2s;
        font-family: "Fira Code", "Monaco", "Consolas", monospace;
      }

      .process-button:hover:not(:disabled) {
        background: #047857;
      }

      .process-button:disabled {
        background: #374151;
        cursor: not-allowed;
      }

      .analysis-panel {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        max-height: none;
      }

      .analysis-section {
        margin-bottom: 1.5rem;
        background: #374151;
        padding: 1rem;
        border-radius: 0.5rem;
      }

      .analysis-section h4 {
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #f3f4f6;
      }

      .stat-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .stat-item {
        background: #4b5563;
        padding: 0.5rem;
        border-radius: 0.25rem;
        text-align: center;
      }

      .stat-value {
        font-size: 1.25rem;
        font-weight: 600;
        color: #60a5fa;
      }

      .stat-label {
        font-size: 0.75rem;
        color: #9ca3af;
      }

      .filter-section {
        margin-bottom: 1.5rem;
        background: #374151;
        padding: 1rem;
        border-radius: 0.5rem;
      }

      .filter-section h4 {
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: #f3f4f6;
      }

      .filter-checkbox-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .filter-checkbox-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem;
        border-radius: 0.25rem;
        transition: background 0.2s;
        cursor: pointer;
      }

      .filter-checkbox-item:hover {
        background: rgba(75, 85, 99, 0.5);
      }

      .filter-checkbox-item input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: #60a5fa;
      }

      .filter-checkbox-item label {
        font-size: 0.875rem;
        color: #e5e7eb;
        cursor: pointer;
        user-select: none;
        flex: 1;
      }

      .theme-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #4b5563;
        border-radius: 0.25rem;
      }

      .theme-item {
        padding: 0.5rem;
        border-bottom: 1px solid #4b5563;
        display: flex;
        justify-content: between;
        align-items: center;
      }

      .theme-item:last-child {
        border-bottom: none;
      }

      .theme-label {
        flex: 1;
        font-size: 0.875rem;
      }

      .theme-badge {
        background: #1f2937;
        color: #9ca3af;
        padding: 0.125rem 0.375rem;
        border-radius: 0.125rem;
        font-size: 0.75rem;
      }

      .graph-container {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: #0a0a0a;
      }

      .graph-controls {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: rgba(31, 41, 55, 0.9);
        padding: 0.75rem;
        border-radius: 0.5rem;
        backdrop-filter: blur(8px);
        display: flex;
        gap: 0.5rem;
        z-index: 10;
      }

      .control-button {
        background: #374151;
        border: none;
        color: white;
        padding: 0.5rem;
        border-radius: 0.375rem;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.2s;
        font-family: "Fira Code", "Monaco", "Consolas", monospace;
      }

      .control-button:hover {
        background: #4b5563;
      }

      .control-button:active {
        background: #1f2937;
      }

      .graph-overlay {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(31, 41, 55, 0.3);
        padding: 1.25rem;
        border-radius: 0.75rem;
        backdrop-filter: blur(12px);
        border: 1px solid rgba(55, 65, 81, 0.3);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        z-index: 10;
        overflow: hidden;
      }

      .hover-overlay {
        max-width: 400px;
        max-height: 250px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .selected-overlay {
        max-height: 80vh;
        max-width: 400px;
        overflow-y: auto;
        animation: expandOverlay 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes expandOverlay {
        from {
          max-height: 250px;
          opacity: 0.8;
        }
        to {
          max-height: 80vh;
          opacity: 1;
        }
      }

      .node-details h4 {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: #f9fafb;
        line-height: 1.3;
      }

      .node-details p {
        font-size: 0.875rem;
        color: #d1d5db;
        margin-bottom: 0.75rem;
        line-height: 1.6;
      }

      .node-details .label {
        font-weight: 500;
        color: #9ca3af;
        display: inline-block;
        margin-right: 0.5rem;
      }

      .section-label {
        font-weight: 600;
        color: #60a5fa;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-top: 0.75rem;
        margin-bottom: 0.5rem;
        display: block;
      }

      .node-summary {
        color: #e5e7eb;
        font-size: 0.9rem;
        line-height: 1.6;
        margin-top: 0.5rem;
        white-space: pre-wrap;
      }

      .themes-list {
        margin-top: 1rem;
        padding-left: 0;
        list-style: none;
      }

      .themes-list li {
        color: #93c5fd;
        margin-bottom: 0.5rem;
        padding-left: 1.25rem;
        position: relative;
        line-height: 1.5;
      }

      .themes-list li::before {
        content: "•";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #60a5fa;
      }

      .connected-themes-list {
        margin-top: 0.5rem;
        padding-left: 0;
        list-style: none;
      }

      .connected-themes-list li {
        color: #a5b4fc;
        margin-bottom: 0.75rem;
        padding-left: 1.25rem;
        position: relative;
        line-height: 1.5;
      }

      .connected-themes-list li::before {
        content: "→";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #818cf8;
      }

      .connected-doc {
        color: #9ca3af;
        font-size: 0.85rem;
        font-style: italic;
        margin-left: 0.5rem;
      }

      .quotes-list {
        margin-top: 0.5rem;
        padding-left: 0;
        list-style: none;
      }

      .quotes-list li {
        color: #d1d5db;
        margin-bottom: 0.75rem;
        padding-left: 1rem;
        padding-right: 0.5rem;
        border-left: 3px solid #60a5fa;
        font-style: italic;
        line-height: 1.6;
        background: rgba(96, 165, 250, 0.05);
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
        border-radius: 0 0.25rem 0.25rem 0;
      }

      .expand-hint {
        color: #9ca3af;
        font-size: 0.8rem;
        font-style: italic;
        margin-top: 0.75rem;
        opacity: 0.8;
      }

      .chat-overlay {
        position: absolute;
        top: 1rem;
        left: 370px;
        width: 55%;
        max-width: 650px;
        z-index: 20;
        transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1),
          transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
        border: 1px solid rgba(156, 163, 175, 0.3);
        border-radius: 0.5rem;
      }

      .chat-overlay-centered {
        left: 50%;
        transform: translateX(-50%);
      }

      .chat-overlay-expanded {
        max-height: 60vh;
        overflow: hidden;
      }

      .chat-header {
        padding: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .chat-input-overlay {
        width: 100%;
        background: rgba(31, 41, 55, 0.2);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(156, 163, 175, 0.3);
        padding: 0.75rem;
        border-radius: 0.5rem;
        color: #f9fafb;
        font-size: 0.875rem;
        outline: none;
        transition: all 0.2s;
        box-shadow: none;
        font-family: "Fira Code", "Monaco", "Consolas", monospace;
      }

      .chat-input-overlay:focus {
        background: rgba(31, 41, 55, 0.3);
        border: 1px solid rgba(156, 163, 175, 0.5);
      }

      .typing-cursor {
        display: inline-block;
        margin-left: 2px;
        animation: blink 1s infinite;
        color: #60a5fa;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      .chat-messages {
        max-height: 50vh;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
      }

      .chat-message {
        margin-bottom: 0.75rem;
        padding: 0.75rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        line-height: 1.6;
        background: rgba(31, 41, 55, 0.15);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(156, 163, 175, 0.3);
        box-shadow: none;
        white-space: pre-wrap;
      }

      .chat-message-user {
        background: rgba(31, 41, 55, 0.15);
        border-left: 1px solid rgba(156, 163, 175, 0.3);
      }

      .chat-message-assistant {
        background: rgba(31, 41, 55, 0.15);
        border-left: 1px solid rgba(156, 163, 175, 0.3);
      }

      .progress-bar {
        background: #374151;
        height: 4px;
        border-radius: 2px;
        overflow: hidden;
        margin-top: 0.5rem;
      }

      .progress-fill {
        background: #059669;
        height: 100%;
        transition: width 0.3s ease;
      }

      .loading-state {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: #9ca3af;
      }

      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #374151;
        border-top: 2px solid #059669;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .message {
        padding: 0.75rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
      }

      .message.success {
        background: rgba(5, 150, 105, 0.2);
        border: 1px solid #059669;
        color: #10b981;
      }

      .message.error {
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid #ef4444;
        color: #f87171;
      }

      .message.info {
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid #3b82f6;
        color: #60a5fa;
      }

      .chat-section {
        background: #374151;
        padding: 1rem;
        border-radius: 0.375rem;
        margin-bottom: 0.75rem;
      }

      .chat-input {
        width: 100%;
        background: #1f2937;
        border: 1px solid #4b5563;
        color: white;
        padding: 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        margin-top: 0.5rem;
        font-family: "Fira Code", "Monaco", "Consolas", monospace;
      }

      .chat-input:focus {
        outline: none;
        border-color: #059669;
      }

      .search-results {
        max-height: 150px;
        overflow-y: auto;
        margin-top: 0.5rem;
        border: 1px solid #4b5563;
        border-radius: 0.25rem;
      }

      .search-result-item {
        padding: 0.5rem;
        border-bottom: 1px solid #4b5563;
        cursor: pointer;
        font-size: 0.875rem;
        transition: background 0.2s;
      }

      .search-result-item:hover {
        background: #4b5563;
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .config-section {
        background: #374151;
        padding: 0.75rem;
        border-radius: 0.375rem;
        margin-bottom: 0.75rem;
      }

      .config-section label {
        display: block;
        font-size: 0.75rem;
        color: #d1d5db;
        margin-bottom: 0.25rem;
      }

      .config-section input[type="range"] {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .config-section input[type="checkbox"] {
        margin-right: 0.5rem;
      }

      input[type="file"] {
        display: none;
      }

      /* Ensure all inputs and buttons use monospace font */
      input,
      button,
      textarea {
        font-family: inherit;
      }

      /* Custom scrollbar styles */
      .sidebar::-webkit-scrollbar,
      .analysis-panel::-webkit-scrollbar,
      .theme-list::-webkit-scrollbar,
      .search-results::-webkit-scrollbar {
        width: 8px;
      }

      .sidebar::-webkit-scrollbar-track,
      .analysis-panel::-webkit-scrollbar-track,
      .theme-list::-webkit-scrollbar-track,
      .search-results::-webkit-scrollbar-track {
        background: #1f2937;
      }

      .sidebar::-webkit-scrollbar-thumb,
      .analysis-panel::-webkit-scrollbar-thumb,
      .theme-list::-webkit-scrollbar-thumb,
      .search-results::-webkit-scrollbar-thumb {
        background: #4b5563;
        border-radius: 4px;
      }

      .sidebar::-webkit-scrollbar-thumb:hover,
      .analysis-panel::-webkit-scrollbar-thumb:hover,
      .theme-list::-webkit-scrollbar-thumb:hover,
      .search-results::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useRef, useEffect } = React;

      const EnhancedDocumentAnalyzer = () => {
        // State management
        const [documents, setDocuments] = useState([]);
        const [graphData, setGraphData] = useState(null);
        const [selectedNode, setSelectedNode] = useState(null);
        const [hoveredNode, setHoveredNode] = useState(null);
        const [analysisReport, setAnalysisReport] = useState(null);
        const [loading, setLoading] = useState(false);
        const [processingProgress, setProcessingProgress] = useState(0);
        const [messages, setMessages] = useState([]);

        // Search and chat state
        const [searchQuery, setSearchQuery] = useState("");
        const [searchResults, setSearchResults] = useState([]);
        const [chatInput, setChatInput] = useState("");
        const [chatHistory, setChatHistory] = useState([]);
        const [chatExpanded, setChatExpanded] = useState(false);
        const [sidebarVisible, setSidebarVisible] = useState(true);
        const [typingMessageIndex, setTypingMessageIndex] = useState(null);
        const [displayedText, setDisplayedText] = useState({});
        const [selectedNodeDetails, setSelectedNodeDetails] = useState(null);
        const [typingNodeText, setTypingNodeText] = useState("");

        // Filter state
        const [filters, setFilters] = useState({
          showDocuments: true,
          showSharedThemes: true,
          showUniqueThemes: true,
        });

        // Label visibility state
        const [showLabels, setShowLabels] = useState(false);

        // Highlighted nodes state (for AI-driven highlighting)
        const [highlightedNodeIds, setHighlightedNodeIds] = useState([]);
        const [shouldFlashHighlighted, setShouldFlashHighlighted] =
          useState(false);

        // Configuration state
        const [config, setConfig] = useState({
          minThemeConfidence: 0.7,
          maxThemesPerDocument: 8,
          semanticSimilarityThreshold: 0.7,
          connectionStrengthThreshold: 0.4,
          enableSemanticAnalysis: true,
          enableHierarchicalThemes: true,
        });

        // Refs
        const mountRef = useRef(null);
        const analyzerRef = useRef(null);
        const fileInputRef = useRef(null);
        const chatOverlayRef = useRef(null);
        const chatMessagesRef = useRef(null);
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const nodeObjectsRef = useRef({});
        const labelSpritesRef = useRef([]);
        const showLabelsRef = useRef(false); // Ref for animate loop access
        const flashIntervalRef = useRef(null); // For flashing animation
        const hoveredNodeRef = useRef(null);
        const selectedNodeRef = useRef(null);
        const tubeObjectsRef = useRef([]); // Store tube objects for focus highlighting
        const focusPointRef = useRef(new THREE.Vector3(0, 0, 0)); // Track orbital center
        const controlsRef = useRef({
          rotation: { x: 0, y: 0 },
          autoRotate: true, // Start with auto-rotate enabled
        });

        // Initialize analyzer
        useEffect(() => {
          if (window.CONFIG && window.CONFIG.OPENAI_API_KEY) {
            analyzerRef.current = new DocumentConnectionAnalyzer(
              window.CONFIG.OPENAI_API_KEY
            );
            addMessage(
              "System initialized with enhanced analysis capabilities",
              "success"
            );
          } else {
            addMessage(
              "OpenAI API key not found. Please check your config.js file.",
              "error"
            );
          }
        }, []);

        // Sync hover and selection states with refs for animation loop
        useEffect(() => {
          hoveredNodeRef.current = hoveredNode;
        }, [hoveredNode]);

        useEffect(() => {
          selectedNodeRef.current = selectedNode;
        }, [selectedNode]);

        // Handle click outside chat to collapse it
        useEffect(() => {
          const handleClickOutside = (event) => {
            if (
              chatOverlayRef.current &&
              !chatOverlayRef.current.contains(event.target) &&
              chatExpanded
            ) {
              setChatExpanded(false);
            }
          };

          document.addEventListener("mousedown", handleClickOutside);
          return () => {
            document.removeEventListener("mousedown", handleClickOutside);
          };
        }, [chatExpanded]);

        // Resize renderer when sidebar is toggled
        useEffect(() => {
          if (rendererRef.current && cameraRef.current && mountRef.current) {
            // Wait for CSS transition to complete
            setTimeout(() => {
              const width = mountRef.current.clientWidth;
              const height = mountRef.current.clientHeight;

              cameraRef.current.aspect = width / height;
              cameraRef.current.updateProjectionMatrix();
              rendererRef.current.setSize(width, height);

              console.log("Renderer resized to:", width, "x", height);
            }, 300); // Match CSS transition duration
          }
        }, [sidebarVisible]);

        // Keyboard shortcuts
        useEffect(() => {
          const handleKeyDown = (event) => {
            // Space bar - reset view (only if not focused on an input)
            if (
              event.code === "Space" &&
              event.target.tagName !== "INPUT" &&
              event.target.tagName !== "TEXTAREA"
            ) {
              event.preventDefault();
              resetCamera();
            }
          };

          document.addEventListener("keydown", handleKeyDown);
          return () => {
            document.removeEventListener("keydown", handleKeyDown);
          };
        }, []); // Empty dependency array since resetCamera is stable

        // Typewriter effect for chat messages
        useEffect(() => {
          if (typingMessageIndex !== null && chatHistory[typingMessageIndex]) {
            const message = chatHistory[typingMessageIndex];
            const fullText = message.content;
            let currentIndex = 0;

            const typingInterval = setInterval(() => {
              if (currentIndex <= fullText.length) {
                setDisplayedText((prev) => ({
                  ...prev,
                  [typingMessageIndex]: fullText.slice(0, currentIndex),
                }));
                currentIndex++;
              } else {
                clearInterval(typingInterval);
                setTypingMessageIndex(null);
              }
            }, 10); // 10ms per character (faster)

            return () => clearInterval(typingInterval);
          }
        }, [typingMessageIndex, chatHistory]);

        // Typewriter effect for selected node details
        useEffect(() => {
          if (selectedNodeDetails) {
            const fullText = selectedNodeDetails;
            let currentIndex = 0;

            const typingInterval = setInterval(() => {
              if (currentIndex <= fullText.length) {
                setTypingNodeText(fullText.slice(0, currentIndex));
                currentIndex++;
              } else {
                clearInterval(typingInterval);
              }
            }, 8); // 8ms per character for info box (faster)

            return () => clearInterval(typingInterval);
          } else {
            setTypingNodeText("");
          }
        }, [selectedNodeDetails]);

        // Auto-scroll to bottom when new messages arrive
        useEffect(() => {
          if (
            chatMessagesRef.current &&
            chatExpanded &&
            chatHistory.length > 0
          ) {
            chatMessagesRef.current.scrollTop =
              chatMessagesRef.current.scrollHeight;
          }
        }, [chatHistory, displayedText, chatExpanded]);

        // Apply filters to graph nodes
        // Apply filters to graph nodes
        useEffect(() => {
          if (!graphData || !nodeObjectsRef.current) return;

          console.log("Applying filters:", filters);
          const nodeTypeCounts = {};
          const debugInfo = { shared: 0, unique: 0, documents: 0 };

          Object.values(nodeObjectsRef.current).forEach((mesh) => {
            const nodeData = mesh.userData.nodeData;
            if (!nodeData) return;

            let shouldHighlight = false;
            const nodeType = nodeData.type || "unknown";

            // Count node types for debugging
            nodeTypeCounts[nodeType] = (nodeTypeCounts[nodeType] || 0) + 1;

            // Document nodes (lowercase "document")
            if (nodeType === "document") {
              shouldHighlight = filters.showDocuments;
              debugInfo.documents++;
            }
            // Shared theme nodes (lowercase "shared-theme")
            else if (nodeType === "shared-theme") {
              shouldHighlight = filters.showSharedThemes;
              debugInfo.shared++;
            }
            // Unique theme nodes (lowercase "unique-theme")
            else if (nodeType === "unique-theme") {
              shouldHighlight = filters.showUniqueThemes;
              debugInfo.unique++;
            }

            // Apply visual changes
            if (shouldHighlight) {
              // Highlighted: full opacity and normal emissive
              mesh.material.opacity = 1.0;
              mesh.material.transparent = false;
              mesh.material.emissiveIntensity = 0.3;
            } else {
              // Dimmed: reduced opacity
              mesh.material.opacity = 0.15;
              mesh.material.transparent = true;
              mesh.material.emissiveIntensity = 0.05;
            }
          });

          console.log("Node type counts:", nodeTypeCounts);
          console.log(
            "Filter results - Documents:",
            debugInfo.documents,
            "Shared themes:",
            debugInfo.shared,
            "Unique themes:",
            debugInfo.unique
          );
        }, [filters, graphData]);

        // Update label visibility when showLabels state changes
        useEffect(() => {
          showLabelsRef.current = showLabels; // Update ref for animate loop
          if (labelSpritesRef.current && labelSpritesRef.current.length > 0) {
            labelSpritesRef.current.forEach(({ sprite }) => {
              sprite.visible = showLabels;
            });
          }
        }, [showLabels]);

        // Apply highlighted nodes styling
        useEffect(() => {
          if (!nodeObjectsRef.current || !graphData) return;

          Object.values(nodeObjectsRef.current).forEach((mesh) => {
            const nodeData = mesh.userData.nodeData;
            if (!nodeData) return;

            const isHighlighted =
              highlightedNodeIds.length === 0 ||
              highlightedNodeIds.includes(nodeData.id);

            if (highlightedNodeIds.length > 0) {
              // Special highlighting mode active
              if (isHighlighted) {
                mesh.material.opacity = 1.0;
                mesh.material.transparent = false;
                mesh.material.emissiveIntensity = 0.6;
              } else {
                mesh.material.opacity = 0.1;
                mesh.material.transparent = true;
                mesh.material.emissiveIntensity = 0.02;
              }
            }
            // Note: Regular filter logic in other useEffect will handle normal state
          });
        }, [highlightedNodeIds, graphData]);

        // Handle flashing animation for multiple highlighted nodes
        useEffect(() => {
          // Clear any existing interval
          if (flashIntervalRef.current) {
            clearInterval(flashIntervalRef.current);
            flashIntervalRef.current = null;
          }

          if (
            shouldFlashHighlighted &&
            highlightedNodeIds.length > 1 &&
            nodeObjectsRef.current
          ) {
            let isRed = false;

            flashIntervalRef.current = setInterval(() => {
              highlightedNodeIds.forEach((nodeId) => {
                const mesh = nodeObjectsRef.current[nodeId];
                if (mesh) {
                  if (isRed) {
                    // Flash to bright red
                    mesh.material.color.setHex(0xff0000);
                    mesh.material.emissive.setHex(0xff0000);
                    mesh.material.emissiveIntensity = 1.0;
                  } else {
                    // Return to original color
                    const nodeData = mesh.userData.nodeData;
                    const originalColor = new THREE.Color(
                      nodeData.color || "#60a5fa"
                    );
                    mesh.material.color.copy(originalColor);
                    mesh.material.emissive.copy(originalColor);
                    mesh.material.emissiveIntensity = 0.6;
                  }
                }
              });
              isRed = !isRed;
            }, 500); // Flash every 0.5 seconds
          }

          return () => {
            if (flashIntervalRef.current) {
              clearInterval(flashIntervalRef.current);
              flashIntervalRef.current = null;

              // Restore original colors when stopping flash
              if (nodeObjectsRef.current && highlightedNodeIds.length > 0) {
                highlightedNodeIds.forEach((nodeId) => {
                  const mesh = nodeObjectsRef.current[nodeId];
                  if (mesh && mesh.userData.nodeData) {
                    const nodeData = mesh.userData.nodeData;
                    const originalColor = new THREE.Color(
                      nodeData.color || "#60a5fa"
                    );
                    mesh.material.color.copy(originalColor);
                    mesh.material.emissive.copy(originalColor);
                    mesh.material.emissiveIntensity = 0.6;
                  }
                });
              }
            }
          };
        }, [shouldFlashHighlighted, highlightedNodeIds]);

        // Handle focused node highlighting (only show selected node, its connections, and connected nodes)
        useEffect(() => {
          if (
            !selectedNode ||
            !nodeObjectsRef.current ||
            !tubeObjectsRef.current ||
            !graphData
          )
            return;

          // Find connected node IDs
          const connectedNodeIds = new Set();
          connectedNodeIds.add(selectedNode.id); // Include the selected node itself

          // Find all nodes connected to the selected node via links
          if (graphData.links) {
            graphData.links.forEach((link) => {
              if (link.source === selectedNode.id) {
                connectedNodeIds.add(link.target);
              } else if (link.target === selectedNode.id) {
                connectedNodeIds.add(link.source);
              }
            });
          }

          // Apply highlighting to nodes
          Object.values(nodeObjectsRef.current).forEach((mesh) => {
            const nodeData = mesh.userData.nodeData;
            if (!nodeData) return;

            const isConnected = connectedNodeIds.has(nodeData.id);
            const isSelected = nodeData.id === selectedNode.id;

            if (isSelected) {
              // Selected node: fully bright with stronger emissive
              mesh.material.opacity = 1.0;
              mesh.material.transparent = false;
              mesh.material.emissiveIntensity = 0.8;
            } else if (isConnected) {
              // Connected nodes: bright but less emissive than selected
              mesh.material.opacity = 1.0;
              mesh.material.transparent = false;
              mesh.material.emissiveIntensity = 0.4;
            } else {
              // Unconnected nodes: heavily dimmed
              mesh.material.opacity = 0.05;
              mesh.material.transparent = true;
              mesh.material.emissiveIntensity = 0.01;
            }
          });

          // Apply highlighting to tubes/edges
          tubeObjectsRef.current.forEach((tube) => {
            const userData = tube.userData;
            if (!userData) return;

            const isConnectedTube =
              userData.sourceId === selectedNode.id ||
              userData.targetId === selectedNode.id;

            if (isConnectedTube) {
              // Connected edges: visible
              tube.material.opacity = 0.8;
              tube.material.transparent = true;
            } else {
              // Unconnected edges: heavily dimmed
              tube.material.opacity = 0.02;
              tube.material.transparent = true;
            }
          });
        }, [selectedNode, graphData]);

        // Clear focused highlighting when no node is selected
        useEffect(() => {
          if (
            selectedNode ||
            !nodeObjectsRef.current ||
            !tubeObjectsRef.current
          )
            return;

          // Restore all nodes to normal visibility (will be handled by filter logic)
          Object.values(nodeObjectsRef.current).forEach((mesh) => {
            mesh.material.opacity = 1.0;
            mesh.material.transparent = false;
            mesh.material.emissiveIntensity = 0.3;
          });

          // Restore all tubes to normal visibility
          tubeObjectsRef.current.forEach((tube) => {
            tube.material.opacity = 0.8;
            tube.material.transparent = true;
          });
        }, [selectedNode]);

        // Initialize 3D graph when data is available
        useEffect(() => {
          if (graphData && mountRef.current) {
            console.log("useEffect triggered with graphData:", graphData);
            console.log("Nodes:", graphData.nodes?.length);
            console.log("Links:", graphData.links?.length);
            initializeThreeJSGraph();
          }
        }, [graphData]); // Added proper dependency

        const addMessage = (content, type = "info") => {
          setMessages((prev) => [
            ...prev.slice(-4),
            { content, type, timestamp: Date.now() },
          ]);
        };

        // File parsing functions
        const parseTextFile = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              resolve({
                filename: file.name,
                title: file.name.replace(/\.[^/.]+$/, ""),
                content: e.target.result,
                size: file.size,
                type: "text",
              });
            };
            reader.onerror = reject;
            reader.readAsText(file);
          });
        };

        const parseDocxFile = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const arrayBuffer = e.target.result;
                const result = await mammoth.extractRawText({ arrayBuffer });
                resolve({
                  filename: file.name,
                  title: file.name.replace(/\.[^/.]+$/, ""),
                  content: result.value,
                  size: file.size,
                  type: "docx",
                });
              } catch (error) {
                reject(error);
              }
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
          });
        };

        const parseCsvFile = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const csvText = e.target.result;
                const parsed = Papa.parse(csvText, { header: true });

                // Convert CSV data to readable text format
                let content = `CSV Data from ${file.name}\n\n`;

                // Add headers
                if (parsed.meta.fields) {
                  content += `Columns: ${parsed.meta.fields.join(", ")}\n\n`;
                }

                // Add rows as text descriptions
                parsed.data.forEach((row, idx) => {
                  if (idx < 100) {
                    // Limit to first 100 rows to avoid huge files
                    content += `Row ${idx + 1}:\n`;
                    Object.entries(row).forEach(([key, value]) => {
                      if (value) content += `  ${key}: ${value}\n`;
                    });
                    content += "\n";
                  }
                });

                if (parsed.data.length > 100) {
                  content += `... and ${parsed.data.length - 100} more rows`;
                }

                resolve({
                  filename: file.name,
                  title: file.name.replace(/\.[^/.]+$/, ""),
                  content: content,
                  size: file.size,
                  type: "csv",
                  rowCount: parsed.data.length,
                });
              } catch (error) {
                reject(error);
              }
            };
            reader.onerror = reject;
            reader.readAsText(file);
          });
        };

        const parsePptxFile = (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const arrayBuffer = e.target.result;
                const zip = await JSZip.loadAsync(arrayBuffer);

                let content = `PowerPoint Presentation: ${file.name}\n\n`;
                let slideCount = 0;

                // Extract text from slides
                const slidePromises = [];
                zip.folder("ppt/slides").forEach((relativePath, file) => {
                  if (relativePath.endsWith(".xml")) {
                    slidePromises.push(
                      file.async("text").then((text) => {
                        slideCount++;
                        // Extract text from XML (simple regex approach)
                        const textMatches = text.match(/<a:t>([^<]+)<\/a:t>/g);
                        if (textMatches) {
                          const slideText = textMatches
                            .map((m) => m.replace(/<\/?a:t>/g, ""))
                            .join(" ");
                          return `Slide ${slideCount}:\n${slideText}\n\n`;
                        }
                        return "";
                      })
                    );
                  }
                });

                const slideTexts = await Promise.all(slidePromises);
                content += slideTexts.join("");

                resolve({
                  filename: file.name,
                  title: file.name.replace(/\.[^/.]+$/, ""),
                  content:
                    content ||
                    `PowerPoint presentation with ${slideCount} slides (text extraction failed)`,
                  size: file.size,
                  type: "pptx",
                  slideCount: slideCount,
                });
              } catch (error) {
                reject(error);
              }
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
          });
        };

        const handleFileUpload = async (event) => {
          const files = Array.from(event.target.files);

          try {
            const filePromises = files.map(async (file) => {
              const ext = file.name.split(".").pop().toLowerCase();

              switch (ext) {
                case "txt":
                  return await parseTextFile(file);
                case "docx":
                  return await parseDocxFile(file);
                case "csv":
                  return await parseCsvFile(file);
                case "pptx":
                case "ppt":
                  return await parsePptxFile(file);
                default:
                  throw new Error(`Unsupported file type: ${ext}`);
              }
            });

            const loadedDocs = await Promise.all(filePromises);

            // Validate loaded documents
            const validDocs = loadedDocs.filter((doc) => {
              if (!doc || !doc.title || !doc.content) {
                console.warn("Skipping invalid document:", doc);
                return false;
              }
              return true;
            });

            if (validDocs.length !== loadedDocs.length) {
              addMessage(
                `Loaded ${validDocs.length} valid documents (${
                  loadedDocs.length - validDocs.length
                } skipped due to errors)`,
                "info"
              );
            } else {
              addMessage(`Loaded ${validDocs.length} document(s)`, "success");
            }

            setDocuments((prev) => [...prev, ...validDocs]);
          } catch (error) {
            console.error("File loading error:", error);
            addMessage(`Error loading files: ${error.message}`, "error");
          }
        };

        const processDocuments = async () => {
          if (!analyzerRef.current || documents.length === 0) {
            addMessage(
              "No analyzer available or no documents to process",
              "error"
            );
            return;
          }

          setLoading(true);
          setProcessingProgress(0);
          addMessage("Starting enhanced document analysis...", "info");

          try {
            // Simulate progress updates
            const progressUpdates = [
              { progress: 20, message: "Extracting themes and definitions..." },
              {
                progress: 40,
                message: "Building optimized storage structure...",
              },
              { progress: 60, message: "Performing semantic analysis..." },
              { progress: 80, message: "Building relationship graph..." },
              { progress: 90, message: "Generating analysis report..." },
            ];

            let updateIndex = 0;
            const progressInterval = setInterval(() => {
              if (updateIndex < progressUpdates.length) {
                const update = progressUpdates[updateIndex];
                setProcessingProgress(update.progress);
                addMessage(update.message, "info");
                updateIndex++;
              }
            }, 2000);

            const result = await analyzerRef.current.processDocuments(
              documents,
              config
            );

            clearInterval(progressInterval);
            setProcessingProgress(100);

            if (result.success) {
              setGraphData(result.graphData);
              setAnalysisReport(result.analysisReport);
              addMessage(
                `Analysis completed successfully! Processed ${result.documentIds.length} documents in ${result.processingTime}ms`,
                "success"
              );

              // Log detailed results for debugging
              console.log("Analysis Results:", result);
              console.log("Graph Data:", result.graphData);
              console.log("Analysis Report:", result.analysisReport);
            } else {
              console.error("Analysis failed with details:", result);
              addMessage(`Analysis failed: ${result.error}`, "error");

              // Show additional debug info if available
              if (result.debugInfo) {
                console.log("Debug info:", result.debugInfo);
                if (
                  result.originalError &&
                  result.originalError !== result.error
                ) {
                  addMessage(
                    `Technical details: ${result.originalError}`,
                    "error"
                  );
                }
              }
            }
          } catch (error) {
            console.error("Processing error:", error);
            addMessage(`Processing error: ${error.message}`, "error");
          } finally {
            setLoading(false);
            setProcessingProgress(0);
          }
        };

        const initializeThreeJSGraph = () => {
          console.log("=== initializeThreeJSGraph called ===");
          console.log("mountRef.current:", mountRef.current);
          console.log("graphData:", graphData);

          if (!mountRef.current) {
            console.error("No mount ref!");
            return;
          }

          if (!graphData) {
            console.error("No graph data!");
            return;
          }

          if (!graphData.nodes || graphData.nodes.length === 0) {
            console.error("No nodes in graph data!");
            addMessage("No nodes to display in graph", "error");
            return;
          }

          console.log(
            `Found ${graphData.nodes.length} nodes and ${
              graphData.links?.length || 0
            } links`
          );

          // Clear any existing content
          while (mountRef.current.firstChild) {
            mountRef.current.removeChild(mountRef.current.firstChild);
          }

          // Initialize Three.js scene
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x0a0a0a);
          sceneRef.current = scene;

          // Clear tube objects array
          tubeObjectsRef.current = [];

          const camera = new THREE.PerspectiveCamera(
            75,
            mountRef.current.clientWidth / mountRef.current.clientHeight,
            0.1,
            1000
          );
          camera.position.set(0, 0, 80); // Increased from 50 to zoom out
          cameraRef.current = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(
            mountRef.current.clientWidth,
            mountRef.current.clientHeight
          );
          mountRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          console.log("Scene, camera, and renderer initialized");

          // Add lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(20, 30, 50);
          scene.add(directionalLight);

          // Apply force-directed layout for better organization
          console.log("Applying force-directed layout...");
          applyForceDirectedLayout(graphData);

          graphData.nodes.forEach((node, i) => {
            console.log(
              `Node ${i} (${node.label}): x=${node.x.toFixed(
                2
              )}, y=${node.y.toFixed(2)}, z=${node.z.toFixed(2)}`
            );
          });

          // Create nodes
          const nodeObjects = {};
          labelSpritesRef.current = []; // Store label sprites for dynamic scaling

          console.log("Creating node meshes...");
          graphData.nodes.forEach((node, i) => {
            const size = ((node.size || 5) / 10) * 2; // Doubled node size
            const geometry = new THREE.SphereGeometry(size, 16, 16);

            let color;
            try {
              color = new THREE.Color(node.color || "#60a5fa");
            } catch (e) {
              console.warn(`Invalid color for node ${i}:`, node.color);
              color = new THREE.Color("#60a5fa");
            }

            const material = new THREE.MeshPhongMaterial({
              color: color,
              emissive: color,
              emissiveIntensity: 0.3,
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(node.x / 10, node.y / 10, node.z / 10);
            mesh.userData = { nodeId: node.id, nodeData: node };

            scene.add(mesh);
            nodeObjects[node.id] = mesh;

            // Add text label for document nodes
            if (node.type === "document") {
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.width = 512;
              canvas.height = 128;

              // Set font and measure text
              context.font =
                "Bold 40px 'Fira Code', 'Monaco', 'Consolas', monospace";
              const text = node.label || "Document";
              const metrics = context.measureText(text);
              const textWidth = metrics.width;

              // Clear and draw text
              context.clearRect(0, 0, canvas.width, canvas.height);
              context.fillStyle = "rgba(255, 255, 255, 0.95)";
              context.fillText(text, (canvas.width - textWidth) / 2, 80);

              // Create sprite with smaller base scale
              const texture = new THREE.CanvasTexture(canvas);
              const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
              });
              const sprite = new THREE.Sprite(spriteMaterial);
              sprite.scale.set(12, 3, 1); // Reduced from 20,5 to 12,3
              sprite.visible = false; // Start hidden (default showLabels is false)
              sprite.position.set(
                node.x / 10 + size * 2,
                node.y / 10,
                node.z / 10
              );

              scene.add(sprite);

              // Store sprite reference with base scale for dynamic scaling
              labelSpritesRef.current.push({
                sprite: sprite,
                baseScale: { x: 12, y: 3, z: 1 },
                nodePosition: sprite.position,
              });
            }

            console.log(`Added mesh for node ${i}: ${node.label}`);
          });

          // Store nodeObjects in ref for animation loop access
          nodeObjectsRef.current = nodeObjects;

          console.log(`Created ${Object.keys(nodeObjects).length} node meshes`);

          // Create links with visible tubes
          if (graphData.links && graphData.links.length > 0) {
            console.log("Creating links with tubes...");
            let successfulLinks = 0;

            graphData.links.forEach((link, i) => {
              const sourceNode = graphData.nodes.find(
                (n) => n.id === link.source
              );
              const targetNode = graphData.nodes.find(
                (n) => n.id === link.target
              );

              if (sourceNode && targetNode) {
                // Validate positions
                const sx = sourceNode.x / 10;
                const sy = sourceNode.y / 10;
                const sz = sourceNode.z / 10;
                const tx = targetNode.x / 10;
                const ty = targetNode.y / 10;
                const tz = targetNode.z / 10;

                // Check for valid numbers
                if (
                  isFinite(sx) &&
                  isFinite(sy) &&
                  isFinite(sz) &&
                  isFinite(tx) &&
                  isFinite(ty) &&
                  isFinite(tz)
                ) {
                  try {
                    // Create a tube between the two points
                    const start = new THREE.Vector3(sx, sy, sz);
                    const end = new THREE.Vector3(tx, ty, tz);

                    // Create a curve between start and end
                    const curve = new THREE.LineCurve3(start, end);

                    // Create tube geometry along the curve
                    const tubeGeometry = new THREE.TubeGeometry(
                      curve, // path
                      1, // tubular segments
                      0.08, // radius (thicker = more visible)
                      8, // radial segments
                      false // closed
                    );

                    // Create glowing material
                    const tubeMaterial = new THREE.MeshBasicMaterial({
                      color: 0x60a5fa, // Bright blue
                      transparent: true,
                      opacity: 0.8,
                    });

                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    tube.userData = {
                      sourceId: link.source,
                      targetId: link.target,
                      linkData: link,
                    };
                    scene.add(tube);

                    // Store tube reference for focus highlighting
                    tubeObjectsRef.current.push(tube);
                    successfulLinks++;

                    if (i < 3) {
                      console.log(
                        `✓ Tube link ${i}: ${sourceNode.label} → ${targetNode.label}`
                      );
                    }
                  } catch (error) {
                    console.error(`Error creating tube for link ${i}:`, error);
                  }
                } else {
                  console.warn(
                    `Invalid positions for link ${i}: source(${sx},${sy},${sz}) target(${tx},${ty},${tz})`
                  );
                }
              } else {
                console.warn(
                  `Could not find nodes for link ${i}: source=${link.source}, target=${link.target}`
                );
              }
            });

            console.log(
              `✓ Created ${successfulLinks} tube links out of ${graphData.links.length} total`
            );
          } else {
            console.log("No links to create");
          }

          // Mouse interaction
          const raycaster = new THREE.Raycaster();
          const mouse = new THREE.Vector2();

          const onMouseClick = (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
              Object.values(nodeObjects)
            );

            if (intersects.length > 0) {
              const nodeData = intersects[0].object.userData.nodeData;
              console.log("Node clicked:", nodeData.label);

              // Stop auto-rotate when user clicks a node
              if (controlsRef.current.autoRotate) {
                controlsRef.current.autoRotate = false;
              }

              setSelectedNode(nodeData);

              // Prepare details text for typing effect
              const details = getNodeDetails(nodeData);
              if (details && details.summary) {
                setSelectedNodeDetails(details.summary);
              } else {
                setSelectedNodeDetails(null);
              }

              focusOnNode(nodeData); // Zoom in on clicked node
            }
            // Note: No longer clearing selection when clicking elsewhere
            // Selection only clears via spacebar or Reset View button
          };

          renderer.domElement.addEventListener("click", onMouseClick);

          // Camera controls
          let isDragging = false;
          let previousMousePosition = { x: 0, y: 0 };

          const onMouseDown = (event) => {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };

            // Stop auto-rotate when user starts interacting
            if (controlsRef.current.autoRotate) {
              controlsRef.current.autoRotate = false;
            }

            // Stop flashing when user interacts with graph
            setShouldFlashHighlighted(false);
          };

          const onMouseMove = (event) => {
            // Handle hover detection when not dragging
            if (!isDragging) {
              const rect = renderer.domElement.getBoundingClientRect();
              mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
              mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

              raycaster.setFromCamera(mouse, camera);
              const intersects = raycaster.intersectObjects(
                Object.values(nodeObjects)
              );

              if (intersects.length > 0) {
                const nodeData = intersects[0].object.userData.nodeData;
                setHoveredNode(nodeData);
                renderer.domElement.style.cursor = "pointer";
              } else {
                setHoveredNode(null);
                renderer.domElement.style.cursor = "default";
              }
              return;
            }

            // Handle dragging/rotation
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            controlsRef.current.rotation.y += deltaX * 0.01;
            controlsRef.current.rotation.x += deltaY * 0.01;

            controlsRef.current.rotation.x = Math.max(
              -Math.PI / 2,
              Math.min(Math.PI / 2, controlsRef.current.rotation.x)
            );

            // Get the focus point (selected node position or origin)
            const focusPoint = focusPointRef.current;

            // Calculate distance from camera to focus point
            const dx = camera.position.x - focusPoint.x;
            const dy = camera.position.y - focusPoint.y;
            const dz = camera.position.z - focusPoint.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate new camera position around the focus point
            camera.position.x =
              focusPoint.x +
              distance *
                Math.sin(controlsRef.current.rotation.y) *
                Math.cos(controlsRef.current.rotation.x);
            camera.position.y =
              focusPoint.y +
              distance * Math.sin(controlsRef.current.rotation.x);
            camera.position.z =
              focusPoint.z +
              distance *
                Math.cos(controlsRef.current.rotation.y) *
                Math.cos(controlsRef.current.rotation.x);

            camera.lookAt(focusPoint);

            previousMousePosition = { x: event.clientX, y: event.clientY };
          };

          const onMouseUp = () => {
            isDragging = false;
          };

          const onWheel = (event) => {
            event.preventDefault();

            // Stop auto-rotate when user scrolls
            if (controlsRef.current.autoRotate) {
              controlsRef.current.autoRotate = false;
            }

            const zoomSpeed = event.deltaY * 0.05;

            // Get the focus point (selected node position or origin)
            const focusPoint = focusPointRef.current;

            // Calculate current distance from camera to focus point
            const dx = camera.position.x - focusPoint.x;
            const dy = camera.position.y - focusPoint.y;
            const dz = camera.position.z - focusPoint.z;
            const currentDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate new distance with limits
            const newDistance = Math.max(
              15,
              Math.min(150, currentDistance + zoomSpeed)
            );
            const scale = newDistance / currentDistance;

            // Scale camera position relative to focus point
            camera.position.x = focusPoint.x + dx * scale;
            camera.position.y = focusPoint.y + dy * scale;
            camera.position.z = focusPoint.z + dz * scale;

            camera.lookAt(focusPoint);
          };

          renderer.domElement.addEventListener("mousedown", onMouseDown);
          renderer.domElement.addEventListener("mousemove", onMouseMove);
          renderer.domElement.addEventListener("mouseup", onMouseUp);
          renderer.domElement.addEventListener("wheel", onWheel);
          renderer.domElement.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );

          console.log("Starting render loop...");

          // Render loop
          const animate = () => {
            requestAnimationFrame(animate);

            if (controlsRef.current.autoRotate) {
              controlsRef.current.rotation.y += 0.005;

              // Get focus point and current distance
              const focusPoint = focusPointRef.current;
              const dx = camera.position.x - focusPoint.x;
              const dy = camera.position.y - focusPoint.y;
              const dz = camera.position.z - focusPoint.z;
              const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

              // Rotate around focus point
              camera.position.x =
                focusPoint.x +
                distance * Math.sin(controlsRef.current.rotation.y);
              camera.position.z =
                focusPoint.z +
                distance * Math.cos(controlsRef.current.rotation.y);
              camera.lookAt(focusPoint);
            }

            // Update label scales based on camera distance and visibility
            if (labelSpritesRef.current) {
              labelSpritesRef.current.forEach(
                ({ sprite, baseScale, nodePosition }) => {
                  // Toggle visibility using ref
                  sprite.visible = showLabelsRef.current;

                  if (showLabelsRef.current) {
                    const distance = camera.position.distanceTo(nodePosition);
                    // Scale factor based on distance: closer = smaller, farther = larger
                    // Normalize around distance of 80 (initial camera distance)
                    const scaleFactor = Math.max(
                      0.5,
                      Math.min(2.5, distance / 50)
                    );
                    sprite.scale.set(
                      baseScale.x * scaleFactor,
                      baseScale.y * scaleFactor,
                      baseScale.z
                    );
                  }
                }
              );
            }

            // Update node visual states for hover and selection
            Object.values(nodeObjectsRef.current).forEach((mesh) => {
              const nodeData = mesh.userData.nodeData;
              const isHovered =
                hoveredNodeRef.current &&
                hoveredNodeRef.current.id === nodeData.id;
              const isSelected =
                selectedNodeRef.current &&
                selectedNodeRef.current.id === nodeData.id;

              if (isSelected) {
                // Selected nodes: larger scale and brighter
                mesh.scale.set(1.5, 1.5, 1.5);
                mesh.material.emissiveIntensity = 0.8;
              } else if (isHovered) {
                // Hovered nodes: slightly larger and brighter
                mesh.scale.set(1.3, 1.3, 1.3);
                mesh.material.emissiveIntensity = 0.6;
              } else {
                // Normal nodes
                mesh.scale.set(1, 1, 1);
                mesh.material.emissiveIntensity = 0.3;
              }
            });

            renderer.render(scene, camera);
          };
          animate();

          console.log("Graph initialization complete!");
          addMessage(
            `Graph displayed with ${graphData.nodes.length} nodes`,
            "success"
          );
        };

        const applyForceDirectedLayout = (graphData) => {
          console.log(
            "=== Starting applyForceDirectedLayout (orbital layout) ==="
          );

          if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
            console.error("Invalid graphData");
            return;
          }

          const nodeCount = graphData.nodes.length;
          const isValid = (n) => n != null && isFinite(n) && !isNaN(n);

          // Helper to validate node positions
          const validateNode = (node, fallbackIndex) => {
            if (!isValid(node.x) || !isValid(node.y) || !isValid(node.z)) {
              const angle = (fallbackIndex / nodeCount) * Math.PI * 2;
              node.x = Math.cos(angle) * 150;
              node.y = 0;
              node.z = Math.sin(angle) * 150;
            }
          };

          // 🧩 Parent → children mapping
          const parentToChildren = {};
          if (graphData.links) {
            graphData.links.forEach((link) => {
              if (!parentToChildren[link.source])
                parentToChildren[link.source] = [];
              parentToChildren[link.source].push(link.target);
            });
          }

          // 🌐 INITIAL PARENT DISTRIBUTION (document nodes only)
          const parents = graphData.nodes.filter((n) => n.type === "DOCUMENT");
          const children = graphData.nodes.filter((n) => n.type !== "DOCUMENT");

          for (let i = 0; i < parents.length; i++) {
            const parent = parents[i];
            const angle = (i / parents.length) * Math.PI * 2;
            const radius = 60; // Reduced from 90 to bring nodes very close together
            parent.x = Math.cos(angle) * radius;
            parent.y = (Math.random() - 0.5) * 15; // Reduced vertical spread from 20
            parent.z = Math.sin(angle) * radius;
            validateNode(parent, i);
          }

          // 🪐 CHILDREN ORBITAL LAYOUT
          const orbitRadius = 22; // Reduced from 28 - children very close to parents
          for (const parentId in parentToChildren) {
            const parent = graphData.nodes.find((n) => n.id === parentId);
            if (!parent) continue;

            const childIds = parentToChildren[parentId];
            const childCount = childIds.length;

            for (let i = 0; i < childCount; i++) {
              const child = graphData.nodes.find((n) => n.id === childIds[i]);
              if (!child) continue;

              // Compute orbital position
              const angle = (i / childCount) * Math.PI * 2;
              const tilt = (Math.random() - 0.5) * 0.5; // some z-axis variance
              const radius = orbitRadius + Math.random() * 20;

              child.x = parent.x + Math.cos(angle) * radius;
              child.y = parent.y + Math.sin(angle) * radius * tilt;
              child.z = parent.z + Math.sin(angle) * radius;
            }
          }

          // 💥 Add global repulsion for better overall spacing
          const iterations = 150;
          const velocities = new Map();
          for (let i = 0; i < nodeCount; i++) {
            velocities.set(graphData.nodes[i].id, { x: 0, y: 0, z: 0 });
          }

          for (let iter = 0; iter < iterations; iter++) {
            const forces = new Map();
            for (let i = 0; i < nodeCount; i++) {
              forces.set(graphData.nodes[i].id, { x: 0, y: 0, z: 0 });
            }

            // Repulsion between all nodes
            for (let i = 0; i < nodeCount; i++) {
              for (let j = i + 1; j < nodeCount; j++) {
                const n1 = graphData.nodes[i];
                const n2 = graphData.nodes[j];
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const dz = n2.z - n1.z;
                const distSq = Math.max(1, dx * dx + dy * dy + dz * dz);
                const dist = Math.sqrt(distSq);
                const repulsion = 5000 / distSq;

                const fx = (dx / dist) * repulsion;
                const fy = (dy / dist) * repulsion;
                const fz = (dz / dist) * repulsion;

                const f1 = forces.get(n1.id);
                const f2 = forces.get(n2.id);

                f1.x -= fx;
                f1.y -= fy;
                f1.z -= fz;
                f2.x += fx;
                f2.y += fy;
                f2.z += fz;
              }
            }

            // Apply velocity/damping
            const damping = 0.85;
            for (let i = 0; i < nodeCount; i++) {
              const node = graphData.nodes[i];
              const f = forces.get(node.id);
              const v = velocities.get(node.id);

              v.x = (v.x + f.x) * damping;
              v.y = (v.y + f.y) * damping;
              v.z = (v.z + f.z) * damping;

              node.x += v.x;
              node.y += v.y;
              node.z += v.z;
            }
          }

          // 🌎 Center and scale the graph
          let cx = 0,
            cy = 0,
            cz = 0;
          for (const node of graphData.nodes) {
            cx += node.x;
            cy += node.y;
            cz += node.z;
          }
          cx /= nodeCount;
          cy /= nodeCount;
          cz /= nodeCount;

          for (const node of graphData.nodes) {
            node.x -= cx;
            node.y -= cy;
            node.z -= cz;
          }

          console.log("✓ Orbital layout complete!");
        };

        const updateConfig = (key, value) => {
          setConfig((prev) => ({ ...prev, [key]: value }));
        };

        const handleSearch = (query) => {
          setSearchQuery(query);
          if (!query.trim() || !graphData) {
            setSearchResults([]);
            return;
          }

          const lowerQuery = query.toLowerCase();
          const results = [];

          // Search in document nodes
          graphData.nodes.forEach((node) => {
            if (node.label.toLowerCase().includes(lowerQuery)) {
              results.push({
                id: node.id,
                label: node.label,
                type: node.type,
                relevance: node.label.toLowerCase() === lowerQuery ? 1 : 0.5,
              });
            }
          });

          // Sort by relevance
          results.sort((a, b) => b.relevance - a.relevance);
          setSearchResults(results.slice(0, 10));
        };

        const handleSearchSelect = (nodeId) => {
          if (sceneRef.current && cameraRef.current) {
            const node = graphData.nodes.find((n) => n.id === nodeId);
            if (node) {
              focusOnNode(node);
              setSelectedNode(node);
            }
          }
          setSearchQuery("");
          setSearchResults([]);
        };

        // Helper function to get document summary and details
        const getNodeDetails = (node) => {
          if (!node) return null;

          // Handle THEME and SHARED_THEME nodes differently
          if (node.type === "THEME" || node.type === "SHARED_THEME") {
            const connectedDocuments = [];
            const relatedThemes = [];
            const themeQuotes = [];

            // Find all documents connected to this theme
            if (graphData && graphData.links) {
              graphData.links.forEach((link) => {
                const sourceNode = graphData.nodes.find(
                  (n) => n.id === link.source
                );
                const targetNode = graphData.nodes.find(
                  (n) => n.id === link.target
                );

                // Check if this link connects to our theme node
                if (sourceNode && targetNode) {
                  if (
                    sourceNode.id === node.id &&
                    targetNode.type === "DOCUMENT"
                  ) {
                    connectedDocuments.push(targetNode.label);
                  } else if (
                    targetNode.id === node.id &&
                    sourceNode.type === "DOCUMENT"
                  ) {
                    connectedDocuments.push(sourceNode.label);
                  }
                  // Find related themes (other themes connected to same documents)
                  else if (
                    (sourceNode.id === node.id &&
                      (targetNode.type === "THEME" ||
                        targetNode.type === "SHARED_THEME")) ||
                    (targetNode.id === node.id &&
                      (sourceNode.type === "THEME" ||
                        sourceNode.type === "SHARED_THEME"))
                  ) {
                    const otherTheme =
                      sourceNode.id === node.id ? targetNode : sourceNode;
                    if (!relatedThemes.includes(otherTheme.label)) {
                      relatedThemes.push(otherTheme.label);
                    }
                  }
                }
              });
            }

            // Extract quotes related to this theme from connected documents
            connectedDocuments.forEach((docTitle) => {
              const doc = documents.find(
                (d) => d.title === docTitle || d.filename === docTitle
              );
              if (doc && doc.content) {
                // Search for sentences containing theme-related keywords
                const themeKeywords = node.label
                  .toLowerCase()
                  .split(/[\s,]+/)
                  .filter((w) => w.length > 3);
                const sentences = doc.content.match(/[^.!?]+[.!?]+/g) || [];

                sentences.forEach((sentence) => {
                  const lowerSentence = sentence.toLowerCase();
                  // Check if sentence contains any theme keyword
                  const matchCount = themeKeywords.filter((keyword) =>
                    lowerSentence.includes(keyword)
                  ).length;

                  if (
                    matchCount > 0 &&
                    sentence.trim().length > 40 &&
                    sentence.trim().length < 300
                  ) {
                    themeQuotes.push({
                      text: sentence.trim(),
                      source: docTitle,
                      relevance: matchCount,
                    });
                  }
                });
              }
            });

            // Sort by relevance and take top quotes
            themeQuotes.sort((a, b) => b.relevance - a.relevance);
            const topQuotes = themeQuotes.slice(0, 5);

            // Create a detailed summary for the theme
            let themeSummary = "";

            if (node.type === "SHARED_THEME") {
              themeSummary = `Shared Theme Analysis\n\n`;
              themeSummary += `The theme "${
                node.label
              }" is a shared concept that appears across ${
                connectedDocuments.length
              } document${
                connectedDocuments.length !== 1 ? "s" : ""
              }: ${connectedDocuments.join(", ")}.\n\n`;
              themeSummary += `Why This Theme is Shared:\n`;
              themeSummary += `This theme represents a common thread that connects multiple documents in your collection. Its presence across different sources suggests:\n\n`;
              themeSummary += `• It's a recurring concept or pattern that emerges independently in different contexts\n`;
              themeSummary += `• Multiple authors or sources have identified this as a significant topic\n`;
              themeSummary += `• There may be underlying connections or relationships between these documents\n`;
              themeSummary += `• This concept serves as a bridge for understanding how different pieces of information relate\n\n`;
              themeSummary += `The shared nature of this theme makes it particularly valuable for identifying patterns and connections across your document collection.`;
            } else {
              themeSummary = `Unique Theme Analysis\n\n`;
              themeSummary += `The theme "${node.label}" is unique to ${
                connectedDocuments.length === 1
                  ? connectedDocuments[0]
                  : `${connectedDocuments.length} specific document(s)`
              }.\n\n`;
              themeSummary += `Why This Theme is Unique:\n`;
              themeSummary += `This theme appears exclusively in specific document(s), which suggests:\n\n`;
              themeSummary += `• It represents a specialized concept or topic specific to this source\n`;
              themeSummary += `• The content contains distinctive information not found elsewhere in your collection\n`;
              themeSummary += `• This document may offer unique insights or perspectives on this subject\n`;
              themeSummary += `• The theme helps distinguish this document's specific focus or contribution\n\n`;
              themeSummary += `Unique themes are valuable for understanding what makes each document distinctive within your collection.`;
            }

            return {
              summary: themeSummary,
              fullContent: "",
              themes: [],
              connectedThemes: connectedDocuments.map((doc) => ({
                theme: "Connected Document",
                connectedDocs: [doc],
              })),
              quotes: topQuotes.map((q) => `"${q.text}" — ${q.source}`),
              relatedThemes: relatedThemes,
              doc: null,
              isThemeNode: true,
              connectedDocuments: connectedDocuments,
            };
          }

          // Find the original document
          const doc = documents.find(
            (d) =>
              d.title === node.label ||
              d.filename === node.label ||
              (node.type === "DOCUMENT" && d.title.includes(node.label))
          );

          let summary = "";
          let fullContent = "";
          let themes = [];
          let connectedThemes = [];
          let quotes = [];

          if (doc && doc.content) {
            fullContent = doc.content;

            // Create a meta-description summary that explains what the document is about
            // Rather than just extracting the first paragraphs
            const contentPreview = fullContent.slice(0, 2000); // Look at first 2000 chars for analysis

            // Determine document type/purpose based on content patterns
            let summaryIntro = "This document discusses ";

            if (
              contentPreview.match(
                /\b(research|study|findings|methodology|data|results|analysis)\b/i
              )
            ) {
              summaryIntro = "This research document explores ";
            } else if (
              contentPreview.match(/\b(story|narrative|character|plot|tale)\b/i)
            ) {
              summaryIntro = "This is a story about ";
            } else if (
              contentPreview.match(
                /\b(guide|tutorial|how to|instructions|steps)\b/i
              )
            ) {
              summaryIntro = "This guide explains ";
            } else if (
              contentPreview.match(/\b(report|overview|summary|analysis of)\b/i)
            ) {
              summaryIntro = "This report examines ";
            } else if (
              contentPreview.match(
                /\b(article|discusses|explores|investigates)\b/i
              )
            ) {
              summaryIntro = "This article discusses ";
            }

            // Extract key topics from the first few paragraphs
            const paragraphs = fullContent
              .split("\n\n")
              .filter((p) => p.trim().length > 50);

            // Build the summary with proper formatting
            let formattedSummary = summaryIntro;

            // Add the first paragraph as the main description
            if (paragraphs.length > 0) {
              formattedSummary += paragraphs[0].trim();
            }

            // Add analysis section if there are more paragraphs
            if (paragraphs.length > 1) {
              formattedSummary += "\n\nKey Points:\n";

              // Add up to 3 more paragraphs as bullet points or sections
              const analysisParagraphs = paragraphs.slice(1, 4);
              analysisParagraphs.forEach((para, idx) => {
                const trimmedPara = para.trim().slice(0, 300); // Limit each point
                formattedSummary += `\n• ${trimmedPara}`;
                if (para.length > 300) {
                  formattedSummary += "...";
                }
              });
            }

            summary = formattedSummary;

            if (summary.length > 1800) {
              summary = summary.slice(0, 1800).trim() + "...";
            }

            // Extract quotes (only actual quoted text from people)
            const quoteMatches = fullContent.match(
              /"([^"]+)"|"([^"]+)"|'([^']+)'/g
            );
            if (quoteMatches && quoteMatches.length > 0) {
              quotes = quoteMatches
                .slice(0, 3)
                .map((q) => q.replace(/["'"']/g, "").trim());
            }
            // No fallback - only show quotes if they actually exist in the document

            console.log("Extracted quotes:", quotes);
          }

          // Get themes from metadata
          if (node.metadata) {
            if (node.metadata.themes) {
              themes = node.metadata.themes;
            } else if (analysisReport && analysisReport.documentThemes) {
              const docThemes = analysisReport.documentThemes[node.id] || [];
              themes = docThemes.slice(0, 5);
            }
          }

          // Get connected themes with document references
          if (graphData && graphData.links) {
            console.log(
              "Checking connected themes for:",
              node.label,
              "type:",
              node.type
            );
            console.log("Total links in graph:", graphData.links.length);

            // Find all links connected to this node
            const nodeLinks = graphData.links.filter(
              (link) => link.source === node.id || link.target === node.id
            );

            console.log("Links connected to this node:", nodeLinks.length);

            nodeLinks.forEach((link) => {
              const connectedNodeId =
                link.source === node.id ? link.target : link.source;
              const connectedNode = graphData.nodes.find(
                (n) => n.id === connectedNodeId
              );

              console.log(
                "Examining connected node:",
                connectedNode?.label,
                "type:",
                connectedNode?.type
              );

              // Check if it's a theme or if this is a document and we found another document
              if (connectedNode) {
                // Case 1: Current node is a DOCUMENT, connected to a THEME
                if (
                  node.type === "DOCUMENT" &&
                  (connectedNode.type === "THEME" ||
                    connectedNode.type === "DEFINITION")
                ) {
                  // Find other documents connected to this theme
                  const otherDocs = graphData.links
                    .filter(
                      (l) =>
                        (l.source === connectedNodeId ||
                          l.target === connectedNodeId) &&
                        l.source !== node.id &&
                        l.target !== node.id
                    )
                    .map((l) => {
                      const docId =
                        l.source === connectedNodeId ? l.target : l.source;
                      const docNode = graphData.nodes.find(
                        (n) => n.id === docId && n.type === "DOCUMENT"
                      );
                      return docNode ? docNode.label : null;
                    })
                    .filter(Boolean);

                  console.log(
                    "Theme:",
                    connectedNode.label,
                    "shared with:",
                    otherDocs
                  );

                  connectedThemes.push({
                    theme: connectedNode.label,
                    connectedDocs: otherDocs,
                  });
                }
                // Case 2: Current node is a THEME, show which documents it connects
                else if (
                  (node.type === "THEME" || node.type === "DEFINITION") &&
                  connectedNode.type === "DOCUMENT"
                ) {
                  // For themes, show all connected documents
                  if (
                    !connectedThemes.find(
                      (ct) => ct.theme === "Connected Documents"
                    )
                  ) {
                    connectedThemes.push({
                      theme: "Connected Documents",
                      connectedDocs: [connectedNode.label],
                    });
                  } else {
                    const existingEntry = connectedThemes.find(
                      (ct) => ct.theme === "Connected Documents"
                    );
                    if (
                      existingEntry &&
                      !existingEntry.connectedDocs.includes(connectedNode.label)
                    ) {
                      existingEntry.connectedDocs.push(connectedNode.label);
                    }
                  }
                }
              }
            });

            console.log(
              "Final connected themes for",
              node.label,
              ":",
              connectedThemes
            );
          }

          // Collect key theme child nodes if this is a document
          let keyThemes = [];
          if (node.type === "DOCUMENT" && graphData && graphData.links) {
            const themeNodes = [];

            graphData.links.forEach((link) => {
              const connectedNodeId =
                link.source === node.id ? link.target : link.source;
              const connectedNode = graphData.nodes.find(
                (n) => n.id === connectedNodeId
              );

              if (
                connectedNode &&
                (connectedNode.type === "THEME" ||
                  connectedNode.type === "SHARED_THEME")
              ) {
                themeNodes.push({
                  label: connectedNode.label,
                  type: connectedNode.type,
                  sharedBy: connectedNode.metadata?.sharedBy?.length || 0,
                });
              }
            });

            // Sort by type (shared themes first) and then by number of connections
            themeNodes.sort((a, b) => {
              if (a.type === "SHARED_THEME" && b.type !== "SHARED_THEME")
                return -1;
              if (a.type !== "SHARED_THEME" && b.type === "SHARED_THEME")
                return 1;
              return b.sharedBy - a.sharedBy;
            });

            keyThemes = themeNodes.slice(0, 8); // Limit to top 8 themes
          }

          const result = {
            summary,
            fullContent,
            themes,
            connectedThemes: connectedThemes.slice(0, 5), // Limit to 5 connections
            quotes: quotes.slice(0, 3), // Limit to 3 quotes
            keyThemes: keyThemes, // Add key themes for documents
            doc,
          };

          console.log("getNodeDetails result:", result);
          return result;
        };

        // Parse markdown syntax (bold, headers) to HTML
        const parseMarkdownBold = (text) => {
          if (!text) return text;
          return (
            text
              // Replace ### headers with styled h3 elements
              .replace(
                /^### (.+)$/gm,
                "<h3 style=\"color: #60a5fa; font-size: 1.1rem; font-weight: 600; margin: 1rem 0 0.5rem 0; border-bottom: 1px solid #374151; padding-bottom: 0.25rem; font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;\">$1</h3>"
              )
              // Replace ## headers with styled h2 elements
              .replace(
                /^## (.+)$/gm,
                "<h2 style=\"color: #60a5fa; font-size: 1.2rem; font-weight: 600; margin: 1.2rem 0 0.6rem 0; border-bottom: 1px solid #374151; padding-bottom: 0.25rem; font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;\">$1</h2>"
              )
              // Replace # headers with styled h1 elements
              .replace(
                /^# (.+)$/gm,
                "<h1 style=\"color: #60a5fa; font-size: 1.3rem; font-weight: 700; margin: 1.3rem 0 0.7rem 0; border-bottom: 2px solid #374151; padding-bottom: 0.5rem; font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;\">$1</h1>"
              )
              // Replace **text** with <strong>text</strong>
              .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>")
              .replace(/__([^_]+)__/g, "<strong>$1</strong>")
              // Replace line breaks with <br> for proper formatting
              .replace(/\n/g, "<br>")
          );
        };

        const handleChatSubmit = async () => {
          if (!chatInput.trim() || !analyzerRef.current) return;

          const userMessage = chatInput.trim();
          const lowerMessage = userMessage.toLowerCase();
          setChatInput("");

          // Check for graph control commands
          let commandHandled = false;
          let commandResponse = "";

          // Label control commands
          if (
            lowerMessage.includes("turn off label") ||
            lowerMessage.includes("hide label") ||
            lowerMessage.includes("remove label")
          ) {
            setShowLabels(false);
            commandResponse = "✓ Document labels hidden.";
            commandHandled = true;
          } else if (
            lowerMessage.includes("turn on label") ||
            lowerMessage.includes("show label") ||
            lowerMessage.includes("display label")
          ) {
            setShowLabels(true);
            commandResponse = "✓ Document labels shown.";
            commandHandled = true;
          }
          // Node filter commands
          else if (
            lowerMessage.includes("highlight only document") ||
            lowerMessage.includes("show only document")
          ) {
            setFilters({
              showDocuments: true,
              showSharedThemes: false,
              showUniqueThemes: false,
            });
            commandResponse = "✓ Showing only document nodes.";
            commandHandled = true;
          } else if (
            lowerMessage.includes("highlight connection") ||
            lowerMessage.includes("show connection")
          ) {
            setFilters({
              showDocuments: true,
              showSharedThemes: true,
              showUniqueThemes: true,
            });
            commandResponse = "✓ Showing all nodes and connections.";
            commandHandled = true;
          } else if (
            lowerMessage.includes("show shared theme") ||
            lowerMessage.includes("highlight shared theme")
          ) {
            setFilters({
              showDocuments: true,
              showSharedThemes: true,
              showUniqueThemes: false,
            });
            commandResponse = "✓ Showing documents and shared themes.";
            commandHandled = true;
          } else if (
            lowerMessage.includes("show unique theme") ||
            lowerMessage.includes("highlight unique theme")
          ) {
            setFilters({
              showDocuments: true,
              showSharedThemes: false,
              showUniqueThemes: true,
            });
            commandResponse = "✓ Showing documents and unique themes.";
            commandHandled = true;
          } else if (
            lowerMessage.includes("show all") ||
            lowerMessage.includes("reset filter") ||
            lowerMessage.includes("show everything")
          ) {
            setFilters({
              showDocuments: true,
              showSharedThemes: true,
              showUniqueThemes: true,
            });
            setShowLabels(true);
            commandResponse = "✓ Showing all nodes with labels.";
            commandHandled = true;
          }

          // If a command was handled, respond immediately without calling the API
          if (commandHandled) {
            setChatHistory((prev) => [
              ...prev,
              { role: "user", content: userMessage },
              { role: "assistant", content: commandResponse },
            ]);
            return;
          }

          // Check for content-based highlighting queries
          const isHighlightQuery =
            (lowerMessage.includes("which document") ||
              lowerMessage.includes("what document") ||
              lowerMessage.includes("highlight document")) &&
            (lowerMessage.includes("about") ||
              lowerMessage.includes("mention") ||
              lowerMessage.includes("talk") ||
              lowerMessage.includes("discuss") ||
              lowerMessage.includes("contain"));

          if (isHighlightQuery && documents.length > 0) {
            // Add user message and thinking indicator
            setChatHistory((prev) => [
              ...prev,
              { role: "user", content: userMessage },
              {
                role: "assistant",
                content: "Analyzing documents...",
                isThinking: true,
              },
            ]);
            setLoading(true);

            try {
              // Create a focused prompt to identify relevant documents
              const documentList = documents
                .map(
                  (doc, idx) =>
                    `${idx + 1}. "${doc.title}" (ID: ${
                      doc.filename
                    })\nContent: ${doc.content.slice(0, 800)}...`
                )
                .join("\n\n");

              const highlightPrompt = `Based on this user query: "${userMessage}"

Here are the available documents with their EXACT titles:
${documentList}

Analyze which document(s) are most relevant to the user's query. 

IMPORTANT: Use the EXACT title text as shown above (the text in quotes after the number).

Return ONLY a JSON object with this exact format:
{
  "documentTitles": ["exact title 1", "exact title 2"],
  "explanation": "Brief explanation of why these documents match"
}

If no documents match, return empty array for documentTitles.

Example response format:
{"documentTitles": ["Marine_Biodiversity_and_Coral_Reef_Fish", "sustainable_fisheries_and_ocean_conservation"], "explanation": "These documents discuss ocean life and marine ecosystems."}`;

              const response = await fetch(
                "https://api.openai.com/v1/chat/completions",
                {
                  method: "POST",
                  headers: {
                    Authorization: `Bearer ${window.CONFIG.OPENAI_API_KEY}`,
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify({
                    model: "gpt-4o-mini",
                    messages: [
                      {
                        role: "system",
                        content:
                          "You are a document analysis assistant. Return only valid JSON.",
                      },
                      { role: "user", content: highlightPrompt },
                    ],
                    temperature: 0.3,
                    max_tokens: 300,
                  }),
                }
              );

              const data = await response.json();
              if (!response.ok)
                throw new Error(data.error?.message || "API request failed");

              const aiResponse = data.choices?.[0]?.message?.content || "{}";

              // Parse JSON response
              let result;
              try {
                result = JSON.parse(aiResponse);
              } catch (e) {
                // If JSON parsing fails, try to extract from markdown code blocks
                const jsonMatch =
                  aiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                  aiResponse.match(/```\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                  result = JSON.parse(jsonMatch[1]);
                } else {
                  throw new Error("Could not parse AI response");
                }
              }

              const matchedTitles = result.documentTitles || [];
              const explanation =
                result.explanation || "No matching documents found.";

              console.log("AI returned titles:", matchedTitles);
              console.log(
                "Available nodes:",
                graphData?.nodes?.map((n) => ({ type: n.type, label: n.label }))
              );

              // Find matching document nodes and highlight them (with flexible matching)
              const matchedNodeIds = [];
              const matchedNodes = [];
              if (graphData && graphData.nodes) {
                matchedTitles.forEach((aiTitle) => {
                  const node = graphData.nodes.find((n) => {
                    if (n.type !== "document") return false;

                    const nodeLabel = n.label || n.data?.title || "";
                    const aiTitleNorm = aiTitle.toLowerCase().trim();
                    const nodeLabelNorm = nodeLabel.toLowerCase().trim();

                    // Try exact match, partial match, or if AI title contains node label
                    return (
                      nodeLabelNorm === aiTitleNorm ||
                      nodeLabelNorm.includes(aiTitleNorm) ||
                      aiTitleNorm.includes(nodeLabelNorm)
                    );
                  });

                  if (node) {
                    console.log(`Matched "${aiTitle}" to node "${node.label}"`);
                    matchedNodeIds.push(node.id);
                    matchedNodes.push(node);
                  } else {
                    console.warn(`Could not find node for title: "${aiTitle}"`);
                  }
                });
              }

              console.log("Matched nodes:", matchedNodes.length);

              // Apply highlighting
              setHighlightedNodeIds(matchedNodeIds);

              // If exactly one document found, zoom into it
              if (matchedNodes.length === 1) {
                focusOnNode(matchedNodes[0]);
                setSelectedNode(matchedNodes[0]);
                setShouldFlashHighlighted(false); // No flashing for single node
              } else if (matchedNodes.length > 1) {
                // Enable flashing for multiple documents
                setShouldFlashHighlighted(true);
              }

              // Create response message
              let responseMessage = explanation;
              if (matchedNodeIds.length > 0) {
                responseMessage += `\n\n✓ Highlighted ${matchedNodeIds.length} document(s) in the graph.`;
                if (matchedNodes.length === 1) {
                  responseMessage += `\n\n🔍 Zoomed into "${matchedNodes[0].label}".`;
                }
                responseMessage += `\n\n💡 Click "Show All" or ask me to "reset highlighting" to restore the normal view.`;
              } else {
                responseMessage += "\n\nNo documents were highlighted.";
              }

              setChatHistory((prev) => {
                const filteredHistory = prev.filter((msg) => !msg.isThinking);
                const newHistory = [
                  ...filteredHistory,
                  { role: "assistant", content: responseMessage },
                ];
                setTypingMessageIndex(newHistory.length - 1);
                return newHistory;
              });
            } catch (error) {
              console.error("Highlight query error:", error);
              setChatHistory((prev) => {
                const filteredHistory = prev.filter((msg) => !msg.isThinking);
                return [
                  ...filteredHistory,
                  {
                    role: "assistant",
                    content: `Error analyzing documents: ${error.message}`,
                  },
                ];
              });
            } finally {
              setLoading(false);
            }
            return;
          }

          // Reset highlighting command
          if (
            lowerMessage.includes("reset highlight") ||
            lowerMessage.includes("clear highlight") ||
            lowerMessage.includes("remove highlight")
          ) {
            setHighlightedNodeIds([]);
            setChatHistory((prev) => [
              ...prev,
              { role: "user", content: userMessage },
              {
                role: "assistant",
                content:
                  "✓ Highlighting cleared. All nodes restored to normal view.",
              },
            ]);
            return;
          }

          setChatHistory((prev) => [
            ...prev,
            { role: "user", content: userMessage },
            { role: "assistant", content: "Thinking...", isThinking: true },
          ]);
          setLoading(true);

          try {
            // Build context for the LLM with FULL document content
            const context = {
              documents: documents.map((doc) => ({
                title: doc.title,
                content: doc.content, // Include full content
                filename: doc.filename,
              })),
              analysisReport: analysisReport,
              graphStats: graphData?.metadata,
              totalDocuments: documents.length,
              totalThemes: analysisReport?.overview?.totalThemes || 0,
              sharedThemes: analysisReport?.overview?.sharedThemes || 0,
              topSharedThemes:
                analysisReport?.themeAnalysis?.topSharedThemes
                  ?.slice(0, 5)
                  .map((t) => ({
                    label: t.label,
                    sharedBy: t.sharedBy.length,
                  })) || [],
              connectivity: analysisReport?.connectivity || {},
              themeCategories:
                analysisReport?.themeAnalysis?.themeCategories || {},
            };

            // Create a comprehensive document summary for the prompt
            const documentSummaries = context.documents
              .map((doc, idx) => {
                const preview = doc.content.slice(0, 500); // First 500 chars as preview
                return `Document ${idx + 1}: "${doc.title}"
Filename: ${doc.filename}
Content Preview: ${preview}${doc.content.length > 500 ? "..." : ""}
Full Content Length: ${doc.content.length} characters`;
              })
              .join("\n\n");

            const prompt = `You are an AI assistant with COMPLETE access to the document contents and their relationships. 

DOCUMENT LIBRARY:
${documentSummaries}

ANALYSIS INSIGHTS:
- Total documents: ${context.totalDocuments}
- Total themes identified: ${context.totalThemes}
- Shared themes across documents: ${context.sharedThemes}
- Top shared themes: ${context.topSharedThemes
              .map((t) => `"${t.label}" (${t.sharedBy} docs)`)
              .join(", ")}
- Most connected document: ${
              context.connectivity.mostConnectedDocument?.document?.title ||
              "N/A"
            }
- Isolated documents: ${context.connectivity.isolatedDocuments?.length || 0}

USER QUESTION: ${userMessage}

INSTRUCTIONS:
- Be clear and direct - length should match what's needed to answer properly
- Can be short (1 sentence) or longer (multiple paragraphs) depending on the question
- Use bullet points or numbered lists when listing multiple items
- Add line breaks between sections for readability
- Be specific and cite document titles when relevant
- Format with proper spacing:
  • Use blank lines between paragraphs
  • Use • or numbered lists for multiple items
  • Use **bold** for emphasis on key terms

Answer the question thoroughly but efficiently.`;

            // For document-specific queries, include the full content of relevant documents
            const relevantDocs = documents.filter(
              (doc) =>
                userMessage.toLowerCase().includes(doc.title.toLowerCase()) ||
                userMessage.toLowerCase().includes(doc.filename.toLowerCase())
            );

            let fullContextPrompt = prompt;

            if (relevantDocs.length > 0 && relevantDocs.length <= 3) {
              // If user is asking about specific documents, include their full content
              const fullContents = relevantDocs
                .map(
                  (doc) =>
                    `\n\n=== FULL CONTENT OF "${doc.title}" ===\n${doc.content}\n=== END OF "${doc.title}" ===`
                )
                .join("\n");

              fullContextPrompt = prompt + fullContents;
            } else if (
              userMessage.toLowerCase().includes("summarize") ||
              userMessage.toLowerCase().includes("summary") ||
              userMessage.toLowerCase().includes("about") ||
              userMessage.toLowerCase().includes("content")
            ) {
              // If asking for summaries, include all full contents
              const allContents = documents
                .map(
                  (doc) =>
                    `\n\n=== FULL CONTENT OF "${doc.title}" ===\n${doc.content}\n=== END OF "${doc.title}" ===`
                )
                .join("\n");

              fullContextPrompt = prompt + allContents;
            }

            const response = await fetch(
              "https://api.openai.com/v1/chat/completions",
              {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${window.CONFIG.OPENAI_API_KEY}`,
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  model: "gpt-4o-mini",
                  messages: [
                    {
                      role: "system",
                      content:
                        "You are a helpful assistant analyzing documents. Provide clear, well-formatted responses. Length should match the question - can be brief or detailed as needed. Use bullet points and line breaks for clarity. Use **bold** for emphasis.",
                    },
                    { role: "user", content: fullContextPrompt },
                  ],
                  temperature: 0.7,
                  max_tokens: 600, // Flexible for appropriate response length
                }),
              }
            );

            const data = await response.json();

            if (!response.ok) {
              throw new Error(data.error?.message || "API request failed");
            }

            const assistantMessage =
              data.choices?.[0]?.message?.content ||
              "I apologize, but I could not generate a response.";

            setChatHistory((prev) => {
              // Remove the "Thinking..." message and add the real response
              const filteredHistory = prev.filter((msg) => !msg.isThinking);
              const newHistory = [
                ...filteredHistory,
                { role: "assistant", content: assistantMessage },
              ];
              // Trigger typing animation for the new message
              setTypingMessageIndex(newHistory.length - 1);
              return newHistory;
            });
          } catch (error) {
            console.error("Chat error:", error);
            setChatHistory((prev) => {
              // Remove the "Thinking..." message and add error
              const filteredHistory = prev.filter((msg) => !msg.isThinking);
              return [
                ...filteredHistory,
                {
                  role: "assistant",
                  content: `Error: ${error.message}. Please check your API key and try again.`,
                },
              ];
            });
          } finally {
            setLoading(false);
          }
        };

        const focusOnNode = (node) => {
          if (!cameraRef.current) return;

          const targetPos = new THREE.Vector3(
            node.x / 10,
            node.y / 10,
            node.z / 10
          );

          // Update the focus point to the selected node
          focusPointRef.current.copy(targetPos);

          const distance = 20;
          const direction = new THREE.Vector3(0, 0, 1);

          const startPos = cameraRef.current.position.clone();
          const endPos = targetPos
            .clone()
            .add(direction.multiplyScalar(distance));

          const duration = 1000;
          const startTime = Date.now();

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            cameraRef.current.position.lerpVectors(startPos, endPos, eased);
            cameraRef.current.lookAt(targetPos);

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // After animation completes, update rotation angles to match final camera position
              const dx = cameraRef.current.position.x - targetPos.x;
              const dy = cameraRef.current.position.y - targetPos.y;
              const dz = cameraRef.current.position.z - targetPos.z;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

              controlsRef.current.rotation.x = Math.asin(dy / dist);
              controlsRef.current.rotation.y = Math.atan2(dx, dz);
            }
          };
          animate();
        };

        const toggleAutoRotate = () => {
          const newState = !controlsRef.current.autoRotate;

          // When enabling auto-rotate, sync rotation angles to current camera position
          if (newState && cameraRef.current) {
            const focusPoint = focusPointRef.current;
            const dx = cameraRef.current.position.x - focusPoint.x;
            const dy = cameraRef.current.position.y - focusPoint.y;
            const dz = cameraRef.current.position.z - focusPoint.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate current rotation angles from camera position
            if (distance > 0) {
              controlsRef.current.rotation.x = Math.asin(dy / distance);
              controlsRef.current.rotation.y = Math.atan2(dx, dz);
            }
          }

          controlsRef.current.autoRotate = newState;
        };

        const resetCamera = () => {
          if (!cameraRef.current) return;

          // Reset focus point to origin
          focusPointRef.current.set(0, 0, 0);

          // Clear selected node
          setSelectedNode(null);

          // Clear highlighted nodes (undim all nodes)
          setHighlightedNodeIds([]);

          // Stop any flashing animation
          setShouldFlashHighlighted(false);

          // Restore all nodes to full visibility if they were dimmed
          if (nodeObjectsRef.current) {
            Object.values(nodeObjectsRef.current).forEach((mesh) => {
              mesh.material.opacity = 1.0;
              mesh.material.transparent = false;
              const nodeData = mesh.userData.nodeData;
              if (nodeData) {
                const originalColor = new THREE.Color(
                  nodeData.color || "#60a5fa"
                );
                mesh.material.color.copy(originalColor);
                mesh.material.emissive.copy(originalColor);
                mesh.material.emissiveIntensity = 0.3;
              }
            });
          }

          const startPos = cameraRef.current.position.clone();
          const endPos = new THREE.Vector3(0, 0, 80); // Match initial camera position
          const duration = 1000;
          const startTime = Date.now();

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            cameraRef.current.position.lerpVectors(startPos, endPos, eased);
            cameraRef.current.lookAt(0, 0, 0);

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Reset rotation angles
              controlsRef.current.rotation.x = 0;
              controlsRef.current.rotation.y = 0;
            }
          };
          animate();
        };

        return (
          <div className="container">
            <div className="header">
              <div className="header-title">
                <h1>c•nnect the d•cs</h1>
              </div>
              <div style={{ fontSize: "0.875rem", color: "#9ca3af" }}>
                {documents.length} documents loaded
              </div>
            </div>

            <div className="main-content">
              {/* Sidebar Toggle Button */}
              <button
                className={`sidebar-toggle ${
                  !sidebarVisible ? "" : "sidebar-toggle-hidden"
                }`}
                onClick={() => setSidebarVisible(!sidebarVisible)}
                title={sidebarVisible ? "Hide Sidebar" : "Show Sidebar"}
              >
                {sidebarVisible ? "◀" : "▶"}
              </button>

              <div
                className={`sidebar ${!sidebarVisible ? "sidebar-hidden" : ""}`}
              >
                <div className="sidebar-section">
                  <h3>Document Upload</h3>
                  <div className="file-upload">
                    <div
                      className="upload-button"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <div>📄</div>
                      <div>Drop files here or click to browse</div>
                      <div style={{ fontSize: "0.75rem", marginTop: "0.5rem" }}>
                        Supports .txt, .docx, .csv, .pptx files
                      </div>
                    </div>
                    <input
                      ref={fileInputRef}
                      type="file"
                      multiple
                      accept=".txt,.docx,.csv,.pptx,.ppt"
                      onChange={handleFileUpload}
                    />
                    <button
                      className="process-button"
                      onClick={processDocuments}
                      disabled={loading || documents.length === 0}
                    >
                      {loading ? (
                        <div className="loading-state">
                          <div className="spinner"></div>
                          Processing...
                        </div>
                      ) : (
                        "Analyze Documents"
                      )}
                    </button>
                    {loading && (
                      <div className="progress-bar">
                        <div
                          className="progress-fill"
                          style={{ width: `${processingProgress}%` }}
                        ></div>
                      </div>
                    )}
                  </div>
                </div>

                <div className="sidebar-section">
                  <h3>Display Options</h3>
                  <div className="filter-checkbox-group">
                    <div className="filter-checkbox-item">
                      <input
                        type="checkbox"
                        id="filter-documents"
                        checked={filters.showDocuments}
                        onChange={(e) =>
                          setFilters((prev) => ({
                            ...prev,
                            showDocuments: e.target.checked,
                          }))
                        }
                      />
                      <label htmlFor="filter-documents">
                        📄 Document Nodes
                      </label>
                    </div>
                    <div className="filter-checkbox-item">
                      <input
                        type="checkbox"
                        id="filter-shared-themes"
                        checked={filters.showSharedThemes}
                        onChange={(e) =>
                          setFilters((prev) => ({
                            ...prev,
                            showSharedThemes: e.target.checked,
                          }))
                        }
                      />
                      <label htmlFor="filter-shared-themes">
                        🔗 Shared Themes
                      </label>
                    </div>
                    <div className="filter-checkbox-item">
                      <input
                        type="checkbox"
                        id="filter-unique-themes"
                        checked={filters.showUniqueThemes}
                        onChange={(e) =>
                          setFilters((prev) => ({
                            ...prev,
                            showUniqueThemes: e.target.checked,
                          }))
                        }
                      />
                      <label htmlFor="filter-unique-themes">
                        ⭐ Unique Themes
                      </label>
                    </div>
                    <div className="filter-checkbox-item">
                      <input
                        type="checkbox"
                        id="toggle-labels"
                        checked={showLabels}
                        onChange={(e) => setShowLabels(e.target.checked)}
                      />
                      <label htmlFor="toggle-labels">🏷️ Document Labels</label>
                    </div>
                  </div>
                </div>

                <div className="sidebar-section">
                  <h3>Graph Controls</h3>
                  <div
                    style={{
                      display: "flex",
                      flexDirection: "column",
                      gap: "0.5rem",
                    }}
                  >
                    <button
                      className="control-button"
                      onClick={resetCamera}
                      title="Reset View"
                      style={{
                        width: "100%",
                        padding: "0.75rem",
                        fontSize: "1rem",
                      }}
                    >
                      Reset View
                    </button>
                    <button
                      className="control-button"
                      onClick={toggleAutoRotate}
                      title="Toggle Auto-Rotate"
                      style={{
                        width: "100%",
                        padding: "0.75rem",
                        fontSize: "1rem",
                      }}
                    >
                      Toggle Rotation
                    </button>
                  </div>
                </div>
              </div>

              <div className="graph-container">
                <div
                  ref={mountRef}
                  style={{ width: "100%", height: "100%" }}
                ></div>

                {/* Chat Overlay at Top */}
                <div
                  ref={chatOverlayRef}
                  className={`chat-overlay ${
                    chatExpanded ? "chat-overlay-expanded" : ""
                  } ${!sidebarVisible ? "chat-overlay-centered" : ""}`}
                >
                  <div className="chat-header">
                    <input
                      type="text"
                      className="chat-input-overlay"
                      placeholder="Ask questions about your documents..."
                      value={chatInput}
                      onChange={(e) => setChatInput(e.target.value)}
                      onFocus={() => setChatExpanded(true)}
                      onKeyPress={(e) => {
                        if (e.key === "Enter") {
                          handleChatSubmit();
                        }
                      }}
                    />
                  </div>

                  {chatExpanded && chatHistory.length > 0 && (
                    <div ref={chatMessagesRef} className="chat-messages">
                      {chatHistory.map((msg, idx) => {
                        const isTyping = typingMessageIndex === idx;
                        const textToShow = isTyping
                          ? displayedText[idx] || ""
                          : msg.content;

                        return (
                          <div
                            key={idx}
                            className={`chat-message chat-message-${msg.role}`}
                          >
                            <strong>
                              {msg.role === "user" ? "You" : "Assistant"}:
                            </strong>{" "}
                            <span
                              dangerouslySetInnerHTML={{
                                __html: parseMarkdownBold(textToShow),
                              }}
                            />
                            {isTyping && (
                              <span className="typing-cursor">▋</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>

                {selectedNode && (
                  <div className="graph-overlay selected-overlay">
                    <div className="node-details">
                      <h4>{selectedNode.label}</h4>
                      <p>
                        <span className="label">Type:</span> {selectedNode.type}
                      </p>
                      {(() => {
                        const details = getNodeDetails(selectedNode);
                        return details ? (
                          <>
                            {details.summary && (
                              <>
                                <span className="section-label">Summary</span>
                                <div className="node-summary">
                                  {typingNodeText || details.summary}
                                  {typingNodeText &&
                                    typingNodeText.length <
                                      details.summary.length && (
                                      <span className="typing-cursor">▋</span>
                                    )}
                                </div>
                              </>
                            )}
                            {details.keyThemes &&
                              details.keyThemes.length > 0 && (
                                <>
                                  <span className="section-label">
                                    Key Themes
                                  </span>
                                  <ul className="themes-list">
                                    {details.keyThemes.map((theme, idx) => (
                                      <li key={idx}>
                                        <strong>{theme.label}</strong>
                                        {theme.type === "SHARED_THEME" &&
                                          theme.sharedBy > 1 && (
                                            <span
                                              style={{
                                                fontSize: "0.75rem",
                                                color: "#9ca3af",
                                                marginLeft: "0.5rem",
                                              }}
                                            >
                                              (shared with {theme.sharedBy - 1}{" "}
                                              other
                                              {theme.sharedBy > 2 ? "s" : ""})
                                            </span>
                                          )}
                                      </li>
                                    ))}
                                  </ul>
                                </>
                              )}
                            {details.connectedThemes &&
                              details.connectedThemes.length > 0 && (
                                <>
                                  <span className="section-label">
                                    {details.isThemeNode
                                      ? "Connected Documents"
                                      : "Connected Themes"}
                                  </span>
                                  <ul className="connected-themes-list">
                                    {details.connectedThemes.map(
                                      (item, idx) => (
                                        <li key={idx}>
                                          <strong>{item.theme}</strong>
                                          <span className="connected-doc">
                                            {item.connectedDocs.length > 0 &&
                                              ` (shared with ${item.connectedDocs.join(
                                                ", "
                                              )})`}
                                          </span>
                                        </li>
                                      )
                                    )}
                                  </ul>
                                </>
                              )}
                            {details.relatedThemes &&
                              details.relatedThemes.length > 0 && (
                                <>
                                  <span className="section-label">
                                    Related Themes
                                  </span>
                                  <ul className="themes-list">
                                    {details.relatedThemes.map((theme, idx) => (
                                      <li key={idx}>{theme}</li>
                                    ))}
                                  </ul>
                                </>
                              )}
                            {details.connectedDocuments &&
                              details.connectedDocuments.length > 0 &&
                              !details.connectedThemes && (
                                <>
                                  <span className="section-label">
                                    Appears In
                                  </span>
                                  <ul className="themes-list">
                                    {details.connectedDocuments.map(
                                      (doc, idx) => (
                                        <li key={idx}>{doc}</li>
                                      )
                                    )}
                                  </ul>
                                </>
                              )}
                            {details.quotes && details.quotes.length > 0 && (
                              <>
                                <span className="section-label">
                                  Key Quotes
                                </span>
                                <ul className="quotes-list">
                                  {details.quotes.map((quote, idx) => (
                                    <li key={idx}>{quote}</li>
                                  ))}
                                </ul>
                              </>
                            )}
                            {details.themes && details.themes.length > 0 && (
                              <>
                                <span className="section-label">
                                  Additional Themes
                                </span>
                                <ul className="themes-list">
                                  {details.themes.map((theme, idx) => (
                                    <li key={idx}>{theme}</li>
                                  ))}
                                </ul>
                              </>
                            )}
                          </>
                        ) : (
                          <>
                            {selectedNode.metadata && (
                              <>
                                {selectedNode.metadata.themeCount && (
                                  <p>
                                    <span className="label">Themes:</span>{" "}
                                    {selectedNode.metadata.themeCount}
                                  </p>
                                )}
                                {selectedNode.metadata.sharedBy && (
                                  <p>
                                    <span className="label">Shared by:</span>{" "}
                                    {selectedNode.metadata.sharedBy.length}{" "}
                                    documents
                                  </p>
                                )}
                                {selectedNode.metadata.category && (
                                  <p>
                                    <span className="label">Category:</span>{" "}
                                    {selectedNode.metadata.category}
                                  </p>
                                )}
                              </>
                            )}
                          </>
                        );
                      })()}
                    </div>
                  </div>
                )}

                {hoveredNode && !selectedNode && (
                  <div className="graph-overlay hover-overlay">
                    <div className="node-details">
                      <h4>{hoveredNode.label}</h4>
                      <p style={{ marginBottom: "0.5rem" }}>
                        <span className="label">Type:</span> {hoveredNode.type}
                      </p>
                      {(() => {
                        const details = getNodeDetails(hoveredNode);
                        return details && details.summary ? (
                          <>
                            <span className="section-label">Summary</span>
                            <div className="node-summary">
                              {details.summary.length > 200
                                ? details.summary.substring(0, 200).trim() +
                                  "..."
                                : details.summary}
                            </div>
                          </>
                        ) : hoveredNode.metadata ? (
                          <>
                            <span className="section-label">Metadata</span>
                            <p
                              style={{
                                fontSize: "0.8rem",
                                lineHeight: "1.4",
                                color: "#9ca3af",
                              }}
                            >
                              {hoveredNode.metadata.themeCount &&
                                `${hoveredNode.metadata.themeCount} themes • `}
                              {hoveredNode.metadata.sharedBy &&
                                `Shared by ${hoveredNode.metadata.sharedBy.length} docs`}
                              {hoveredNode.metadata.category &&
                                hoveredNode.metadata.category}
                            </p>
                          </>
                        ) : null;
                      })()}
                      <p className="expand-hint">(Click node for more)</p>
                    </div>
                  </div>
                )}

                {!graphData && (
                  <div
                    style={{
                      position: "absolute",
                      top: "50%",
                      left: "50%",
                      transform: "translate(-50%, -50%)",
                      textAlign: "center",
                      color: "#9ca3af",
                    }}
                  >
                    <div style={{ fontSize: "3rem", marginBottom: "1rem" }}>
                      •
                    </div>
                    <div>
                      Upload documents and click "Analyze Documents" to see the
                      graph
                    </div>
                    <div style={{ fontSize: "0.875rem", marginTop: "0.5rem" }}>
                      Controls: Drag to rotate, Scroll to zoom, Click nodes to
                      select
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      ReactDOM.render(
        <EnhancedDocumentAnalyzer />,
        document.getElementById("root")
      );
    </script>
  </body>
</html>
